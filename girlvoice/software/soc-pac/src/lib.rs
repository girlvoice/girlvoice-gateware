#![doc = "Peripheral access API for SOC microcontrollers (generated using svd2rust v0.33.3 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.33.3/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic {
    use core::marker;
    #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)"]
    pub trait RawReg:
        Copy
        + Default
        + From<bool>
        + core::ops::BitOr<Output = Self>
        + core::ops::BitAnd<Output = Self>
        + core::ops::BitOrAssign
        + core::ops::BitAndAssign
        + core::ops::Not<Output = Self>
        + core::ops::Shl<u8, Output = Self>
    {
        #[doc = " Mask for bits of width `WI`"]
        fn mask<const WI: u8>() -> Self;
        #[doc = " Mask for bits of width 1"]
        fn one() -> Self;
    }
    macro_rules! raw_reg {
        ($ U : ty , $ size : literal , $ mask : ident) => {
            impl RawReg for $U {
                #[inline(always)]
                fn mask<const WI: u8>() -> Self {
                    $mask::<WI>()
                }
                #[inline(always)]
                fn one() -> Self {
                    1
                }
            }
            const fn $mask<const WI: u8>() -> $U {
                <$U>::MAX >> ($size - WI)
            }
            impl FieldSpec for $U {
                type Ux = $U;
            }
        };
    }
    raw_reg!(u8, 8, mask_u8);
    raw_reg!(u16, 16, mask_u16);
    raw_reg!(u32, 32, mask_u32);
    raw_reg!(u64, 64, mask_u64);
    #[doc = " Raw register type"]
    pub trait RegisterSpec {
        #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
        type Ux: RawReg;
    }
    #[doc = " Raw field type"]
    pub trait FieldSpec: Sized {
        #[doc = " Raw field type (`u8`, `u16`, `u32`, ...)."]
        type Ux: Copy + core::fmt::Debug + PartialEq + From<Self>;
    }
    #[doc = " Marker for fields with fixed values"]
    pub trait IsEnum: FieldSpec {}
    #[doc = " Trait implemented by readable registers to enable the `read` method."]
    #[doc = ""]
    #[doc = " Registers marked with `Writable` can be also be `modify`'ed."]
    pub trait Readable: RegisterSpec {}
    #[doc = " Trait implemented by writeable registers."]
    #[doc = ""]
    #[doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
    #[doc = ""]
    #[doc = " Registers marked with `Readable` can be also be `modify`'ed."]
    pub trait Writable: RegisterSpec {
        #[doc = " Is it safe to write any bits to register"]
        type Safety;
        #[doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"]
        const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux;
        #[doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"]
        const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux;
    }
    #[doc = " Reset value of the register."]
    #[doc = ""]
    #[doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
    #[doc = " register by using the `reset` method."]
    pub trait Resettable: RegisterSpec {
        #[doc = " Reset value of the register."]
        const RESET_VALUE: Self::Ux;
        #[doc = " Reset value of the register."]
        #[inline(always)]
        fn reset_value() -> Self::Ux {
            Self::RESET_VALUE
        }
    }
    #[doc = " This structure provides volatile access to registers."]
    #[repr(transparent)]
    pub struct Reg<REG: RegisterSpec> {
        register: vcell::VolatileCell<REG::Ux>,
        _marker: marker::PhantomData<REG>,
    }
    unsafe impl<REG: RegisterSpec> Send for Reg<REG> where REG::Ux: Send {}
    impl<REG: RegisterSpec> Reg<REG> {
        #[doc = " Returns the underlying memory address of register."]
        #[doc = ""]
        #[doc = " ```ignore"]
        #[doc = " let reg_ptr = periph.reg.as_ptr();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn as_ptr(&self) -> *mut REG::Ux {
            self.register.as_ptr()
        }
    }
    impl<REG: Readable> Reg<REG> {
        #[doc = " Reads the contents of a `Readable` register."]
        #[doc = ""]
        #[doc = " You can read the raw contents of a register by using `bits`:"]
        #[doc = " ```ignore"]
        #[doc = " let bits = periph.reg.read().bits();"]
        #[doc = " ```"]
        #[doc = " or get the content of a particular field of a register:"]
        #[doc = " ```ignore"]
        #[doc = " let reader = periph.reg.read();"]
        #[doc = " let bits = reader.field1().bits();"]
        #[doc = " let flag = reader.field2().bit_is_set();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn read(&self) -> R<REG> {
            R {
                bits: self.register.get(),
                _reg: marker::PhantomData,
            }
        }
    }
    impl<REG: Resettable + Writable> Reg<REG> {
        #[doc = " Writes the reset value to `Writable` register."]
        #[doc = ""]
        #[doc = " Resets the register to its initial state."]
        #[inline(always)]
        pub fn reset(&self) {
            self.register.set(REG::RESET_VALUE)
        }
        #[doc = " Writes bits to a `Writable` register."]
        #[doc = ""]
        #[doc = " You can write raw bits into a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
        #[doc = " ```"]
        #[doc = " or write only the fields you need:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " In the latter case, other fields will be set to their reset value."]
        #[inline(always)]
        pub fn write<F>(&self, f: F)
        where
            F: FnOnce(&mut W<REG>) -> &mut W<REG>,
        {
            self.register.set(
                f(&mut W {
                    bits: REG::RESET_VALUE & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                        | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                    _reg: marker::PhantomData,
                })
                .bits,
            );
        }
    }
    impl<REG: Writable> Reg<REG> {
        #[doc = " Writes 0 to a `Writable` register."]
        #[doc = ""]
        #[doc = " Similar to `write`, but unused bits will contain 0."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Unsafe to use with registers which don't allow to write 0."]
        #[inline(always)]
        pub unsafe fn write_with_zero<F>(&self, f: F)
        where
            F: FnOnce(&mut W<REG>) -> &mut W<REG>,
        {
            self.register.set(
                f(&mut W {
                    bits: REG::Ux::default(),
                    _reg: marker::PhantomData,
                })
                .bits,
            );
        }
    }
    impl<REG: Readable + Writable> Reg<REG> {
        #[doc = " Modifies the contents of the register by reading and then writing it."]
        #[doc = ""]
        #[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
        #[doc = "    r.bits() | 3"]
        #[doc = " ) });"]
        #[doc = " ```"]
        #[doc = " or"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " Other fields will have the value they had before the call to `modify`."]
        #[inline(always)]
        pub fn modify<F>(&self, f: F)
        where
            for<'w> F: FnOnce(&R<REG>, &'w mut W<REG>) -> &'w mut W<REG>,
        {
            let bits = self.register.get();
            self.register.set(
                f(
                    &R {
                        bits,
                        _reg: marker::PhantomData,
                    },
                    &mut W {
                        bits: bits & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                            | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                        _reg: marker::PhantomData,
                    },
                )
                .bits,
            );
        }
    }
    impl<REG: Readable> core::fmt::Debug for crate::generic::Reg<REG>
    where
        R<REG>: core::fmt::Debug,
    {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            core::fmt::Debug::fmt(&self.read(), f)
        }
    }
    #[doc(hidden)]
    pub mod raw {
        use super::{marker, BitM, FieldSpec, RegisterSpec, Unsafe, Writable};
        pub struct R<REG: RegisterSpec> {
            pub(crate) bits: REG::Ux,
            pub(super) _reg: marker::PhantomData<REG>,
        }
        pub struct W<REG: RegisterSpec> {
            #[doc = "Writable bits"]
            pub(crate) bits: REG::Ux,
            pub(super) _reg: marker::PhantomData<REG>,
        }
        pub struct FieldReader<FI = u8>
        where
            FI: FieldSpec,
        {
            pub(crate) bits: FI::Ux,
            _reg: marker::PhantomData<FI>,
        }
        impl<FI: FieldSpec> FieldReader<FI> {
            #[doc = " Creates a new instance of the reader."]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) const fn new(bits: FI::Ux) -> Self {
                Self {
                    bits,
                    _reg: marker::PhantomData,
                }
            }
        }
        pub struct BitReader<FI = bool> {
            pub(crate) bits: bool,
            _reg: marker::PhantomData<FI>,
        }
        impl<FI> BitReader<FI> {
            #[doc = " Creates a new instance of the reader."]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) const fn new(bits: bool) -> Self {
                Self {
                    bits,
                    _reg: marker::PhantomData,
                }
            }
        }
        pub struct FieldWriter<'a, REG, const WI: u8, FI = u8, Safety = Unsafe>
        where
            REG: Writable + RegisterSpec,
            FI: FieldSpec,
        {
            pub(crate) w: &'a mut W<REG>,
            pub(crate) o: u8,
            _field: marker::PhantomData<(FI, Safety)>,
        }
        impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
        where
            REG: Writable + RegisterSpec,
            FI: FieldSpec,
        {
            #[doc = " Creates a new instance of the writer"]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) fn new(w: &'a mut W<REG>, o: u8) -> Self {
                Self {
                    w,
                    o,
                    _field: marker::PhantomData,
                }
            }
        }
        pub struct BitWriter<'a, REG, FI = bool, M = BitM>
        where
            REG: Writable + RegisterSpec,
            bool: From<FI>,
        {
            pub(crate) w: &'a mut W<REG>,
            pub(crate) o: u8,
            _field: marker::PhantomData<(FI, M)>,
        }
        impl<'a, REG, FI, M> BitWriter<'a, REG, FI, M>
        where
            REG: Writable + RegisterSpec,
            bool: From<FI>,
        {
            #[doc = " Creates a new instance of the writer"]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) fn new(w: &'a mut W<REG>, o: u8) -> Self {
                Self {
                    w,
                    o,
                    _field: marker::PhantomData,
                }
            }
        }
    }
    #[doc = " Register reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
    #[doc = " method."]
    pub type R<REG> = raw::R<REG>;
    impl<REG: RegisterSpec> R<REG> {
        #[doc = " Reads raw bits from register."]
        #[inline(always)]
        pub const fn bits(&self) -> REG::Ux {
            self.bits
        }
    }
    impl<REG: RegisterSpec, FI> PartialEq<FI> for R<REG>
    where
        REG::Ux: PartialEq,
        FI: Copy,
        REG::Ux: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&REG::Ux::from(*other))
        }
    }
    #[doc = " Register writer."]
    #[doc = ""]
    #[doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
    pub type W<REG> = raw::W<REG>;
    impl<REG: Writable> W<REG> {
        #[doc = " Writes raw bits to the register."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
        #[inline(always)]
        pub unsafe fn bits(&mut self, bits: REG::Ux) -> &mut Self {
            self.bits = bits;
            self
        }
    }
    impl<REG> W<REG>
    where
        REG: Writable<Safety = Safe>,
    {
        #[doc = " Writes raw bits to the register."]
        #[inline(always)]
        pub fn set(&mut self, bits: REG::Ux) -> &mut Self {
            self.bits = bits;
            self
        }
    }
    #[doc = " Field reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of fields."]
    pub type FieldReader<FI = u8> = raw::FieldReader<FI>;
    #[doc = " Bit-wise field reader"]
    pub type BitReader<FI = bool> = raw::BitReader<FI>;
    impl<FI: FieldSpec> FieldReader<FI> {
        #[doc = " Reads raw bits from field."]
        #[inline(always)]
        pub const fn bits(&self) -> FI::Ux {
            self.bits
        }
    }
    impl<FI: FieldSpec> core::fmt::Debug for FieldReader<FI> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            core::fmt::Debug::fmt(&self.bits, f)
        }
    }
    impl<FI> PartialEq<FI> for FieldReader<FI>
    where
        FI: FieldSpec + Copy,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&FI::Ux::from(*other))
        }
    }
    impl<FI> PartialEq<FI> for BitReader<FI>
    where
        FI: Copy,
        bool: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&bool::from(*other))
        }
    }
    impl<FI> BitReader<FI> {
        #[doc = " Value of the field as raw bits."]
        #[inline(always)]
        pub const fn bit(&self) -> bool {
            self.bits
        }
        #[doc = " Returns `true` if the bit is clear (0)."]
        #[inline(always)]
        pub const fn bit_is_clear(&self) -> bool {
            !self.bit()
        }
        #[doc = " Returns `true` if the bit is set (1)."]
        #[inline(always)]
        pub const fn bit_is_set(&self) -> bool {
            self.bit()
        }
    }
    impl<FI> core::fmt::Debug for BitReader<FI> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            core::fmt::Debug::fmt(&self.bits, f)
        }
    }
    #[doc = " Marker for register/field writers which can take any value of specified width"]
    pub struct Safe;
    #[doc = " You should check that value is allowed to pass to register/field writer marked with this"]
    pub struct Unsafe;
    #[doc = " Marker for field writers are safe to write in specified inclusive range"]
    pub struct Range<const MIN: u64, const MAX: u64>;
    #[doc = " Marker for field writers are safe to write in specified inclusive range"]
    pub struct RangeFrom<const MIN: u64>;
    #[doc = " Marker for field writers are safe to write in specified inclusive range"]
    pub struct RangeTo<const MAX: u64>;
    #[doc = " Write field Proxy"]
    pub type FieldWriter<'a, REG, const WI: u8, FI = u8, Safety = Unsafe> =
        raw::FieldWriter<'a, REG, WI, FI, Safety>;
    impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
    {
        #[doc = " Field width"]
        pub const WIDTH: u8 = WI;
        #[doc = " Field width"]
        #[inline(always)]
        pub const fn width(&self) -> u8 {
            WI
        }
        #[doc = " Field offset"]
        #[inline(always)]
        pub const fn offset(&self) -> u8 {
            self.o
        }
    }
    impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
        #[inline(always)]
        pub unsafe fn bits(self, value: FI::Ux) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::mask::<WI>() << self.o);
            self.w.bits |= (REG::Ux::from(value) & REG::Ux::mask::<WI>()) << self.o;
            self.w
        }
    }
    impl<'a, REG, const WI: u8, FI> FieldWriter<'a, REG, WI, FI, Safe>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, const MIN: u64, const MAX: u64>
        FieldWriter<'a, REG, WI, FI, Range<MIN, MAX>>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
        u64: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            {
                let value = u64::from(value);
                assert!(value >= MIN && value <= MAX);
            }
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, const MIN: u64> FieldWriter<'a, REG, WI, FI, RangeFrom<MIN>>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
        u64: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            {
                let value = u64::from(value);
                assert!(value >= MIN);
            }
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, const MAX: u64> FieldWriter<'a, REG, WI, FI, RangeTo<MAX>>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
        u64: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            {
                let value = u64::from(value);
                assert!(value <= MAX);
            }
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
    where
        REG: Writable + RegisterSpec,
        FI: IsEnum,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Writes `variant` to the field"]
        #[inline(always)]
        pub fn variant(self, variant: FI) -> &'a mut W<REG> {
            unsafe { self.bits(FI::Ux::from(variant)) }
        }
    }
    macro_rules! bit_proxy {
        ($ writer : ident , $ mwv : ident) => {
            #[doc(hidden)]
            pub struct $mwv;
            #[doc = " Bit-wise write field proxy"]
            pub type $writer<'a, REG, FI = bool> = raw::BitWriter<'a, REG, FI, $mwv>;
            impl<'a, REG, FI> $writer<'a, REG, FI>
            where
                REG: Writable + RegisterSpec,
                bool: From<FI>,
            {
                #[doc = " Field width"]
                pub const WIDTH: u8 = 1;
                #[doc = " Field width"]
                #[inline(always)]
                pub const fn width(&self) -> u8 {
                    Self::WIDTH
                }
                #[doc = " Field offset"]
                #[inline(always)]
                pub const fn offset(&self) -> u8 {
                    self.o
                }
                #[doc = " Writes bit to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W<REG> {
                    self.w.bits &= !(REG::Ux::one() << self.o);
                    self.w.bits |= (REG::Ux::from(value) & REG::Ux::one()) << self.o;
                    self.w
                }
                #[doc = " Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: FI) -> &'a mut W<REG> {
                    self.bit(bool::from(variant))
                }
            }
        };
    }
    bit_proxy!(BitWriter, BitM);
    bit_proxy!(BitWriter1S, Bit1S);
    bit_proxy!(BitWriter0C, Bit0C);
    bit_proxy!(BitWriter1C, Bit1C);
    bit_proxy!(BitWriter0S, Bit0S);
    bit_proxy!(BitWriter1T, Bit1T);
    bit_proxy!(BitWriter0T, Bit0T);
    impl<'a, REG, FI> BitWriter<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::one() << self.o;
            self.w
        }
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::one() << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1S<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::one() << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0C<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::one() << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1C<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Clears the field bit by passing one"]
        #[inline(always)]
        pub fn clear_bit_by_one(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::one() << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0S<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Sets the field bit by passing zero"]
        #[inline(always)]
        pub fn set_bit_by_zero(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::one() << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1T<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing one"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::one() << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0T<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing zero"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::one() << self.o);
            self.w
        }
    }
}
#[cfg(feature = "rt")]
extern "C" {
    fn timer0();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    pub _handler: unsafe extern "C" fn(),
    pub _reserved: usize,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[no_mangle]
pub static __EXTERNAL_INTERRUPTS: [Vector; 1] = [Vector { _handler: timer0 }];
#[doc(hidden)]
pub mod interrupt {
    #[doc = r"Enumeration of all the interrupts."]
    #[derive(Copy, Clone, Debug, PartialEq, Eq)]
    #[repr(u16)]
    pub enum Interrupt {
        #[doc = "0 - timer0"]
        timer0 = 0,
    }
    #[doc = r" TryFromInterruptError"]
    #[derive(Debug, Copy, Clone)]
    pub struct TryFromInterruptError(());
    impl Interrupt {
        #[doc = r" Attempt to convert a given value into an `Interrupt`"]
        #[inline]
        pub fn try_from(value: u8) -> Result<Self, TryFromInterruptError> {
            match value {
                0 => Ok(Interrupt::timer0),
                _ => Err(TryFromInterruptError(())),
            }
        }
    }
    #[cfg(feature = "rt")]
    #[macro_export]
    #[doc = r" Assigns a handler to an interrupt"]
    #[doc = r""]
    #[doc = r" This macro takes two arguments: the name of an interrupt and the path to the"]
    #[doc = r" function that will be used as the handler of that interrupt. That function"]
    #[doc = r" must have signature `fn()`."]
    #[doc = r""]
    #[doc = r" Optionally, a third argument may be used to declare interrupt local data."]
    #[doc = r" The handler will have exclusive access to these *local* variables on each"]
    #[doc = r" invocation. If the third argument is used then the signature of the handler"]
    #[doc = r" function must be `fn(&mut $NAME::Locals)` where `$NAME` is the first argument"]
    #[doc = r" passed to the macro."]
    #[doc = r""]
    #[doc = r" # Example"]
    #[doc = r""]
    #[doc = r" ``` ignore"]
    #[doc = r" interrupt!(TIM2, periodic);"]
    #[doc = r""]
    #[doc = r" fn periodic() {"]
    #[doc = r#"     print!(".");"#]
    #[doc = r" }"]
    #[doc = r""]
    #[doc = r" interrupt!(TIM3, tick, locals: {"]
    #[doc = r"     tick: bool = false;"]
    #[doc = r" });"]
    #[doc = r""]
    #[doc = r" fn tick(locals: &mut TIM3::Locals) {"]
    #[doc = r"     locals.tick = !locals.tick;"]
    #[doc = r""]
    #[doc = r"     if locals.tick {"]
    #[doc = r#"         println!("Tick");"#]
    #[doc = r"     } else {"]
    #[doc = r#"         println!("Tock");"#]
    #[doc = r"     }"]
    #[doc = r" }"]
    #[doc = r" ```"]
    macro_rules ! interrupt { ($ NAME : ident , $ path : path , locals : { $ ($ lvar : ident : $ lty : ty = $ lval : expr ;) * }) => { # [allow (non_snake_case)]
mod $ NAME { pub struct Locals { $ (pub $ lvar : $ lty ,) * } } # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; static mut LOCALS : self :: $ NAME :: Locals = self :: $ NAME :: Locals { $ ($ lvar : $ lval ,) * } ; let f : fn (& mut self :: $ NAME :: Locals) = $ path ; f (unsafe { & mut LOCALS }) ; } } ; ($ NAME : ident , $ path : path) => { # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; let f : fn () = $ path ; f () ; } } }
}
pub use self::interrupt::Interrupt;
#[doc = "uart0"]
pub struct Uart0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart0 {}
impl Uart0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0xf000_0200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart0 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart0").finish()
    }
}
#[doc = "uart0"]
pub mod uart0 {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        tx_data: TxData,
        _reserved1: [u8; 0x03],
        rx_data: RxData,
        _reserved2: [u8; 0x03],
        tx_ready: TxReady,
        _reserved3: [u8; 0x03],
        rx_avail: RxAvail,
        _reserved4: [u8; 0x03],
        divisor: Divisor,
    }
    impl RegisterBlock {
        #[doc = "0x00 - A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
        #[inline(always)]
        pub const fn tx_data(&self) -> &TxData {
            &self.tx_data
        }
        #[doc = "0x04 - A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
        #[inline(always)]
        pub const fn rx_data(&self) -> &RxData {
            &self.rx_data
        }
        #[doc = "0x08 - A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
        #[inline(always)]
        pub const fn tx_ready(&self) -> &TxReady {
            &self.tx_ready
        }
        #[doc = "0x0c - A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
        #[inline(always)]
        pub const fn rx_avail(&self) -> &RxAvail {
            &self.rx_avail
        }
        #[doc = "0x10 - A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
        #[inline(always)]
        pub const fn divisor(&self) -> &Divisor {
            &self.divisor
        }
    }
    #[doc = "tx_data (rw) register accessor: A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`tx_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tx_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tx_data`]
module"]
    #[doc(alias = "tx_data")]
    pub type TxData = crate::Reg<tx_data::TxDataSpec>;
    #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
    pub mod tx_data {
        #[doc = "Register `tx_data` reader"]
        pub type R = crate::R<TxDataSpec>;
        #[doc = "Register `tx_data` writer"]
        pub type W = crate::W<TxDataSpec>;
        #[doc = "Field `data` writer - data field"]
        pub type DataW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl W {
            #[doc = "Bits 0:7 - data field"]
            #[inline(always)]
            #[must_use]
            pub fn data(&mut self) -> DataW<TxDataSpec> {
                DataW::new(self, 0)
            }
        }
        #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`tx_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tx_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TxDataSpec;
        impl crate::RegisterSpec for TxDataSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`tx_data::R`](R) reader structure"]
        impl crate::Readable for TxDataSpec {}
        #[doc = "`write(|w| ..)` method takes [`tx_data::W`](W) writer structure"]
        impl crate::Writable for TxDataSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets tx_data to value 0"]
        impl crate::Resettable for TxDataSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
    #[doc = "rx_data (rw) register accessor: A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rx_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rx_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rx_data`]
module"]
    #[doc(alias = "rx_data")]
    pub type RxData = crate::Reg<rx_data::RxDataSpec>;
    #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
    pub mod rx_data {
        #[doc = "Register `rx_data` reader"]
        pub type R = crate::R<RxDataSpec>;
        #[doc = "Register `rx_data` writer"]
        pub type W = crate::W<RxDataSpec>;
        #[doc = "Field `data` reader - data field"]
        pub type DataR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - data field"]
            #[inline(always)]
            pub fn data(&self) -> DataR {
                DataR::new(self.bits)
            }
        }
        impl W {}
        #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rx_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rx_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RxDataSpec;
        impl crate::RegisterSpec for RxDataSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`rx_data::R`](R) reader structure"]
        impl crate::Readable for RxDataSpec {}
        #[doc = "`write(|w| ..)` method takes [`rx_data::W`](W) writer structure"]
        impl crate::Writable for RxDataSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets rx_data to value 0"]
        impl crate::Resettable for RxDataSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
    #[doc = "tx_ready (rw) register accessor: A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`tx_ready::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tx_ready::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tx_ready`]
module"]
    #[doc(alias = "tx_ready")]
    pub type TxReady = crate::Reg<tx_ready::TxReadySpec>;
    #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
    pub mod tx_ready {
        #[doc = "Register `tx_ready` reader"]
        pub type R = crate::R<TxReadySpec>;
        #[doc = "Register `tx_ready` writer"]
        pub type W = crate::W<TxReadySpec>;
        #[doc = "Field `txe` reader - txe field"]
        pub type TxeR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - txe field"]
            #[inline(always)]
            pub fn txe(&self) -> TxeR {
                TxeR::new((self.bits & 1) != 0)
            }
        }
        impl W {}
        #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`tx_ready::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tx_ready::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TxReadySpec;
        impl crate::RegisterSpec for TxReadySpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`tx_ready::R`](R) reader structure"]
        impl crate::Readable for TxReadySpec {}
        #[doc = "`write(|w| ..)` method takes [`tx_ready::W`](W) writer structure"]
        impl crate::Writable for TxReadySpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets tx_ready to value 0"]
        impl crate::Resettable for TxReadySpec {
            const RESET_VALUE: u8 = 0;
        }
    }
    #[doc = "rx_avail (rw) register accessor: A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rx_avail::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rx_avail::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rx_avail`]
module"]
    #[doc(alias = "rx_avail")]
    pub type RxAvail = crate::Reg<rx_avail::RxAvailSpec>;
    #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
    pub mod rx_avail {
        #[doc = "Register `rx_avail` reader"]
        pub type R = crate::R<RxAvailSpec>;
        #[doc = "Register `rx_avail` writer"]
        pub type W = crate::W<RxAvailSpec>;
        #[doc = "Field `rxe` reader - rxe field"]
        pub type RxeR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - rxe field"]
            #[inline(always)]
            pub fn rxe(&self) -> RxeR {
                RxeR::new((self.bits & 1) != 0)
            }
        }
        impl W {}
        #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rx_avail::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rx_avail::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RxAvailSpec;
        impl crate::RegisterSpec for RxAvailSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`rx_avail::R`](R) reader structure"]
        impl crate::Readable for RxAvailSpec {}
        #[doc = "`write(|w| ..)` method takes [`rx_avail::W`](W) writer structure"]
        impl crate::Writable for RxAvailSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets rx_avail to value 0"]
        impl crate::Resettable for RxAvailSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
    #[doc = "divisor (rw) register accessor: A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`divisor::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`divisor::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@divisor`]
module"]
    #[doc(alias = "divisor")]
    pub type Divisor = crate::Reg<divisor::DivisorSpec>;
    #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
    pub mod divisor {
        #[doc = "Register `divisor` reader"]
        pub type R = crate::R<DivisorSpec>;
        #[doc = "Register `divisor` writer"]
        pub type W = crate::W<DivisorSpec>;
        #[doc = "Field `div` reader - div field"]
        pub type DivR = crate::FieldReader<u32>;
        #[doc = "Field `div` writer - div field"]
        pub type DivW<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        impl R {
            #[doc = "Bits 0:23 - div field"]
            #[inline(always)]
            pub fn div(&self) -> DivR {
                DivR::new(self.bits & 0x00ff_ffff)
            }
        }
        impl W {
            #[doc = "Bits 0:23 - div field"]
            #[inline(always)]
            #[must_use]
            pub fn div(&mut self) -> DivW<DivisorSpec> {
                DivW::new(self, 0)
            }
        }
        #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`divisor::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`divisor::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DivisorSpec;
        impl crate::RegisterSpec for DivisorSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`divisor::R`](R) reader structure"]
        impl crate::Readable for DivisorSpec {}
        #[doc = "`write(|w| ..)` method takes [`divisor::W`](W) writer structure"]
        impl crate::Writable for DivisorSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets divisor to value 0"]
        impl crate::Resettable for DivisorSpec {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[doc = "timer0"]
pub struct Timer0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer0 {}
impl Timer0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer0::RegisterBlock = 0xf000_0300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer0 {
    type Target = timer0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer0").finish()
    }
}
#[doc = "timer0"]
pub mod timer0 {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        enable: Enable,
        mode: Mode,
        _reserved2: [u8; 0x02],
        reload: Reload,
        counter: Counter,
        _reserved4: [u8; 0x04],
        ev_enable: EvEnable,
        ev_pending: EvPending,
    }
    impl RegisterBlock {
        #[doc = "0x00 - A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
        #[inline(always)]
        pub const fn enable(&self) -> &Enable {
            &self.enable
        }
        #[doc = "0x01 - A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
        #[inline(always)]
        pub const fn mode(&self) -> &Mode {
            &self.mode
        }
        #[doc = "0x04 - A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
        #[inline(always)]
        pub const fn reload(&self) -> &Reload {
            &self.reload
        }
        #[doc = "0x08 - A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
        #[inline(always)]
        pub const fn counter(&self) -> &Counter {
            &self.counter
        }
        #[doc = "0x10 - A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
        #[inline(always)]
        pub const fn ev_enable(&self) -> &EvEnable {
            &self.ev_enable
        }
        #[doc = "0x11 - A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
        #[inline(always)]
        pub const fn ev_pending(&self) -> &EvPending {
            &self.ev_pending
        }
    }
    #[doc = "enable (rw) register accessor: A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`enable::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`enable::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@enable`]
module"]
    #[doc(alias = "enable")]
    pub type Enable = crate::Reg<enable::EnableSpec>;
    #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
    pub mod enable {
        #[doc = "Register `enable` reader"]
        pub type R = crate::R<EnableSpec>;
        #[doc = "Register `enable` writer"]
        pub type W = crate::W<EnableSpec>;
        #[doc = "Field `enable` reader - enable field"]
        pub type EnableR = crate::BitReader;
        #[doc = "Field `enable` writer - enable field"]
        pub type EnableW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - enable field"]
            #[inline(always)]
            pub fn enable(&self) -> EnableR {
                EnableR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - enable field"]
            #[inline(always)]
            #[must_use]
            pub fn enable(&mut self) -> EnableW<EnableSpec> {
                EnableW::new(self, 0)
            }
        }
        #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`enable::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`enable::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct EnableSpec;
        impl crate::RegisterSpec for EnableSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`enable::R`](R) reader structure"]
        impl crate::Readable for EnableSpec {}
        #[doc = "`write(|w| ..)` method takes [`enable::W`](W) writer structure"]
        impl crate::Writable for EnableSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets enable to value 0"]
        impl crate::Resettable for EnableSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
    #[doc = "mode (rw) register accessor: A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`mode::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mode::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mode`]
module"]
    #[doc(alias = "mode")]
    pub type Mode = crate::Reg<mode::ModeSpec>;
    #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
    pub mod mode {
        #[doc = "Register `mode` reader"]
        pub type R = crate::R<ModeSpec>;
        #[doc = "Register `mode` writer"]
        pub type W = crate::W<ModeSpec>;
        #[doc = "Field `periodic` reader - periodic field"]
        pub type PeriodicR = crate::BitReader;
        #[doc = "Field `periodic` writer - periodic field"]
        pub type PeriodicW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - periodic field"]
            #[inline(always)]
            pub fn periodic(&self) -> PeriodicR {
                PeriodicR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - periodic field"]
            #[inline(always)]
            #[must_use]
            pub fn periodic(&mut self) -> PeriodicW<ModeSpec> {
                PeriodicW::new(self, 0)
            }
        }
        #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`mode::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mode::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ModeSpec;
        impl crate::RegisterSpec for ModeSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`mode::R`](R) reader structure"]
        impl crate::Readable for ModeSpec {}
        #[doc = "`write(|w| ..)` method takes [`mode::W`](W) writer structure"]
        impl crate::Writable for ModeSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets mode to value 0"]
        impl crate::Resettable for ModeSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
    #[doc = "reload (rw) register accessor: A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`reload::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`reload::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reload`]
module"]
    #[doc(alias = "reload")]
    pub type Reload = crate::Reg<reload::ReloadSpec>;
    #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
    pub mod reload {
        #[doc = "Register `reload` reader"]
        pub type R = crate::R<ReloadSpec>;
        #[doc = "Register `reload` writer"]
        pub type W = crate::W<ReloadSpec>;
        #[doc = "Field `value` reader - value field"]
        pub type ValueR = crate::FieldReader<u32>;
        #[doc = "Field `value` writer - value field"]
        pub type ValueW<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - value field"]
            #[inline(always)]
            pub fn value(&self) -> ValueR {
                ValueR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - value field"]
            #[inline(always)]
            #[must_use]
            pub fn value(&mut self) -> ValueW<ReloadSpec> {
                ValueW::new(self, 0)
            }
        }
        #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`reload::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`reload::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ReloadSpec;
        impl crate::RegisterSpec for ReloadSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`reload::R`](R) reader structure"]
        impl crate::Readable for ReloadSpec {}
        #[doc = "`write(|w| ..)` method takes [`reload::W`](W) writer structure"]
        impl crate::Writable for ReloadSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets reload to value 0"]
        impl crate::Resettable for ReloadSpec {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "counter (rw) register accessor: A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`counter::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`counter::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@counter`]
module"]
    #[doc(alias = "counter")]
    pub type Counter = crate::Reg<counter::CounterSpec>;
    #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
    pub mod counter {
        #[doc = "Register `counter` reader"]
        pub type R = crate::R<CounterSpec>;
        #[doc = "Register `counter` writer"]
        pub type W = crate::W<CounterSpec>;
        #[doc = "Field `value` reader - value field"]
        pub type ValueR = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:31 - value field"]
            #[inline(always)]
            pub fn value(&self) -> ValueR {
                ValueR::new(self.bits)
            }
        }
        impl W {}
        #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`counter::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`counter::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CounterSpec;
        impl crate::RegisterSpec for CounterSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`counter::R`](R) reader structure"]
        impl crate::Readable for CounterSpec {}
        #[doc = "`write(|w| ..)` method takes [`counter::W`](W) writer structure"]
        impl crate::Writable for CounterSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets counter to value 0"]
        impl crate::Resettable for CounterSpec {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ev_enable (rw) register accessor: A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_enable::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_enable::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ev_enable`]
module"]
    #[doc(alias = "ev_enable")]
    pub type EvEnable = crate::Reg<ev_enable::EvEnableSpec>;
    #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
    pub mod ev_enable {
        #[doc = "Register `ev_enable` reader"]
        pub type R = crate::R<EvEnableSpec>;
        #[doc = "Register `ev_enable` writer"]
        pub type W = crate::W<EvEnableSpec>;
        #[doc = "Field `mask` reader - mask field"]
        pub type MaskR = crate::BitReader;
        #[doc = "Field `mask` writer - mask field"]
        pub type MaskW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - mask field"]
            #[inline(always)]
            pub fn mask(&self) -> MaskR {
                MaskR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - mask field"]
            #[inline(always)]
            #[must_use]
            pub fn mask(&mut self) -> MaskW<EvEnableSpec> {
                MaskW::new(self, 0)
            }
        }
        #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_enable::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_enable::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct EvEnableSpec;
        impl crate::RegisterSpec for EvEnableSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`ev_enable::R`](R) reader structure"]
        impl crate::Readable for EvEnableSpec {}
        #[doc = "`write(|w| ..)` method takes [`ev_enable::W`](W) writer structure"]
        impl crate::Writable for EvEnableSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets ev_enable to value 0"]
        impl crate::Resettable for EvEnableSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
    #[doc = "ev_pending (rw) register accessor: A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_pending::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_pending::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ev_pending`]
module"]
    #[doc(alias = "ev_pending")]
    pub type EvPending = crate::Reg<ev_pending::EvPendingSpec>;
    #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
    pub mod ev_pending {
        #[doc = "Register `ev_pending` reader"]
        pub type R = crate::R<EvPendingSpec>;
        #[doc = "Register `ev_pending` writer"]
        pub type W = crate::W<EvPendingSpec>;
        #[doc = "Field `mask` reader - mask field"]
        pub type MaskR = crate::BitReader;
        #[doc = "Field `mask` writer - mask field"]
        pub type MaskW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - mask field"]
            #[inline(always)]
            pub fn mask(&self) -> MaskR {
                MaskR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - mask field"]
            #[inline(always)]
            #[must_use]
            pub fn mask(&mut self) -> MaskW<EvPendingSpec> {
                MaskW::new(self, 0)
            }
        }
        #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_pending::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_pending::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct EvPendingSpec;
        impl crate::RegisterSpec for EvPendingSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`ev_pending::R`](R) reader structure"]
        impl crate::Readable for EvPendingSpec {}
        #[doc = "`write(|w| ..)` method takes [`ev_pending::W`](W) writer structure"]
        impl crate::Writable for EvPendingSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets ev_pending to value 0"]
        impl crate::Resettable for EvPendingSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
}
#[doc = "I2CFIFO"]
pub struct I2cfifo {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2cfifo {}
impl I2cfifo {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2cfifo::RegisterBlock = 0xa000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2cfifo::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2cfifo {
    type Target = i2cfifo::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2cfifo {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2cfifo").finish()
    }
}
#[doc = "I2CFIFO"]
pub mod i2cfifo {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x02],
        i2cc1: I2cc1,
        _reserved1: [u8; 0x0f],
        i2ctxfifo_lsb: I2ctxfifoLsb,
        i2ctxfifo_msb: I2ctxfifoMsb,
        i2crxfifo: I2crxfifo,
        _reserved4: [u8; 0x02],
        i2cfifosr_lsb: I2cfifosrLsb,
        i2cfifosr_msb: I2cfifosrMsb,
        _reserved6: [u8; 0x0d],
        i2ctxfifobyteavail: I2ctxfifobyteavail,
    }
    impl RegisterBlock {
        #[doc = "0x02 - "]
        #[inline(always)]
        pub const fn i2cc1(&self) -> &I2cc1 {
            &self.i2cc1
        }
        #[doc = "0x12 - "]
        #[inline(always)]
        pub const fn i2ctxfifo_lsb(&self) -> &I2ctxfifoLsb {
            &self.i2ctxfifo_lsb
        }
        #[doc = "0x13 - "]
        #[inline(always)]
        pub const fn i2ctxfifo_msb(&self) -> &I2ctxfifoMsb {
            &self.i2ctxfifo_msb
        }
        #[doc = "0x14 - "]
        #[inline(always)]
        pub const fn i2crxfifo(&self) -> &I2crxfifo {
            &self.i2crxfifo
        }
        #[doc = "0x18 - "]
        #[inline(always)]
        pub const fn i2cfifosr_lsb(&self) -> &I2cfifosrLsb {
            &self.i2cfifosr_lsb
        }
        #[doc = "0x19 - "]
        #[inline(always)]
        pub const fn i2cfifosr_msb(&self) -> &I2cfifosrMsb {
            &self.i2cfifosr_msb
        }
        #[doc = "0x27 - "]
        #[inline(always)]
        pub const fn i2ctxfifobyteavail(&self) -> &I2ctxfifobyteavail {
            &self.i2ctxfifobyteavail
        }
    }
    #[doc = "I2CC1 (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2cc1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2cc1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@i2cc1`]
module"]
    #[doc(alias = "I2CC1")]
    pub type I2cc1 = crate::Reg<i2cc1::I2cc1Spec>;
    #[doc = ""]
    pub mod i2cc1 {
        #[doc = "Register `I2CC1` reader"]
        pub type R = crate::R<I2cc1Spec>;
        #[doc = "Register `I2CC1` writer"]
        pub type W = crate::W<I2cc1Spec>;
        #[doc = "Field `i2c_en` reader - "]
        pub type I2cEnR = crate::BitReader;
        #[doc = "Field `i2c_en` writer - "]
        pub type I2cEnW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn i2c_en(&self) -> I2cEnR {
                I2cEnR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 7"]
            #[inline(always)]
            #[must_use]
            pub fn i2c_en(&mut self) -> I2cEnW<I2cc1Spec> {
                I2cEnW::new(self, 7)
            }
        }
        #[doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2cc1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2cc1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct I2cc1Spec;
        impl crate::RegisterSpec for I2cc1Spec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`i2cc1::R`](R) reader structure"]
        impl crate::Readable for I2cc1Spec {}
        #[doc = "`write(|w| ..)` method takes [`i2cc1::W`](W) writer structure"]
        impl crate::Writable for I2cc1Spec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets I2CC1 to value 0x9a"]
        impl crate::Resettable for I2cc1Spec {
            const RESET_VALUE: u8 = 0x9a;
        }
    }
    #[doc = "I2CTXFIFO_LSB (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2ctxfifo_lsb::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2ctxfifo_lsb::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@i2ctxfifo_lsb`]
module"]
    #[doc(alias = "I2CTXFIFO_LSB")]
    pub type I2ctxfifoLsb = crate::Reg<i2ctxfifo_lsb::I2ctxfifoLsbSpec>;
    #[doc = ""]
    pub mod i2ctxfifo_lsb {
        #[doc = "Register `I2CTXFIFO_LSB` reader"]
        pub type R = crate::R<I2ctxfifoLsbSpec>;
        #[doc = "Register `I2CTXFIFO_LSB` writer"]
        pub type W = crate::W<I2ctxfifoLsbSpec>;
        #[doc = "Field `txlsb` reader - "]
        pub type TxlsbR = crate::FieldReader;
        #[doc = "Field `txlsb` writer - "]
        pub type TxlsbW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn txlsb(&self) -> TxlsbR {
                TxlsbR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            #[must_use]
            pub fn txlsb(&mut self) -> TxlsbW<I2ctxfifoLsbSpec> {
                TxlsbW::new(self, 0)
            }
        }
        #[doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2ctxfifo_lsb::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2ctxfifo_lsb::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct I2ctxfifoLsbSpec;
        impl crate::RegisterSpec for I2ctxfifoLsbSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`i2ctxfifo_lsb::R`](R) reader structure"]
        impl crate::Readable for I2ctxfifoLsbSpec {}
        #[doc = "`write(|w| ..)` method takes [`i2ctxfifo_lsb::W`](W) writer structure"]
        impl crate::Writable for I2ctxfifoLsbSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets I2CTXFIFO_LSB to value 0"]
        impl crate::Resettable for I2ctxfifoLsbSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
    #[doc = "I2CTXFIFO_MSB (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2ctxfifo_msb::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2ctxfifo_msb::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@i2ctxfifo_msb`]
module"]
    #[doc(alias = "I2CTXFIFO_MSB")]
    pub type I2ctxfifoMsb = crate::Reg<i2ctxfifo_msb::I2ctxfifoMsbSpec>;
    #[doc = ""]
    pub mod i2ctxfifo_msb {
        #[doc = "Register `I2CTXFIFO_MSB` reader"]
        pub type R = crate::R<I2ctxfifoMsbSpec>;
        #[doc = "Register `I2CTXFIFO_MSB` writer"]
        pub type W = crate::W<I2ctxfifoMsbSpec>;
        #[doc = "Field `cmd` reader - "]
        pub type CmdR = crate::FieldReader;
        #[doc = "Field `cmd` writer - "]
        pub type CmdW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            #[doc = "Bits 0:1"]
            #[inline(always)]
            pub fn cmd(&self) -> CmdR {
                CmdR::new(self.bits & 3)
            }
        }
        impl W {
            #[doc = "Bits 0:1"]
            #[inline(always)]
            #[must_use]
            pub fn cmd(&mut self) -> CmdW<I2ctxfifoMsbSpec> {
                CmdW::new(self, 0)
            }
        }
        #[doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2ctxfifo_msb::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2ctxfifo_msb::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct I2ctxfifoMsbSpec;
        impl crate::RegisterSpec for I2ctxfifoMsbSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`i2ctxfifo_msb::R`](R) reader structure"]
        impl crate::Readable for I2ctxfifoMsbSpec {}
        #[doc = "`write(|w| ..)` method takes [`i2ctxfifo_msb::W`](W) writer structure"]
        impl crate::Writable for I2ctxfifoMsbSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets I2CTXFIFO_MSB to value 0"]
        impl crate::Resettable for I2ctxfifoMsbSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
    #[doc = "I2CRXFIFO (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2crxfifo::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2crxfifo::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@i2crxfifo`]
module"]
    #[doc(alias = "I2CRXFIFO")]
    pub type I2crxfifo = crate::Reg<i2crxfifo::I2crxfifoSpec>;
    #[doc = ""]
    pub mod i2crxfifo {
        #[doc = "Register `I2CRXFIFO` reader"]
        pub type R = crate::R<I2crxfifoSpec>;
        #[doc = "Register `I2CRXFIFO` writer"]
        pub type W = crate::W<I2crxfifoSpec>;
        #[doc = "Field `rx_data` reader - "]
        pub type RxDataR = crate::FieldReader;
        #[doc = "Field `rx_data` writer - "]
        pub type RxDataW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `dfirst` reader - "]
        pub type DfirstR = crate::BitReader;
        #[doc = "Field `dfirst` writer - "]
        pub type DfirstW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn rx_data(&self) -> RxDataR {
                RxDataR::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn dfirst(&self) -> DfirstR {
                DfirstR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            #[must_use]
            pub fn rx_data(&mut self) -> RxDataW<I2crxfifoSpec> {
                RxDataW::new(self, 0)
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            #[must_use]
            pub fn dfirst(&mut self) -> DfirstW<I2crxfifoSpec> {
                DfirstW::new(self, 0)
            }
        }
        #[doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2crxfifo::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2crxfifo::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct I2crxfifoSpec;
        impl crate::RegisterSpec for I2crxfifoSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`i2crxfifo::R`](R) reader structure"]
        impl crate::Readable for I2crxfifoSpec {}
        #[doc = "`write(|w| ..)` method takes [`i2crxfifo::W`](W) writer structure"]
        impl crate::Writable for I2crxfifoSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u16 = 0;
        }
        #[doc = "`reset()` method sets I2CRXFIFO to value 0"]
        impl crate::Resettable for I2crxfifoSpec {
            const RESET_VALUE: u16 = 0;
        }
    }
    #[doc = "I2CFIFOSR_LSB (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2cfifosr_lsb::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2cfifosr_lsb::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@i2cfifosr_lsb`]
module"]
    #[doc(alias = "I2CFIFOSR_LSB")]
    pub type I2cfifosrLsb = crate::Reg<i2cfifosr_lsb::I2cfifosrLsbSpec>;
    #[doc = ""]
    pub mod i2cfifosr_lsb {
        #[doc = "Register `I2CFIFOSR_LSB` reader"]
        pub type R = crate::R<I2cfifosrLsbSpec>;
        #[doc = "Register `I2CFIFOSR_LSB` writer"]
        pub type W = crate::W<I2cfifosrLsbSpec>;
        #[doc = "Field `arblost` reader - "]
        pub type ArblostR = crate::BitReader;
        #[doc = "Field `arblost` writer - "]
        pub type ArblostW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `busy` reader - "]
        pub type BusyR = crate::BitReader;
        #[doc = "Field `busy` writer - "]
        pub type BusyW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `rnack` reader - "]
        pub type RnackR = crate::BitReader;
        #[doc = "Field `rnack` writer - "]
        pub type RnackW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `rxoverfl` reader - "]
        pub type RxoverflR = crate::BitReader;
        #[doc = "Field `rxoverfl` writer - "]
        pub type RxoverflW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `txoverfl` reader - "]
        pub type TxoverflR = crate::BitReader;
        #[doc = "Field `txoverfl` writer - "]
        pub type TxoverflW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `txserr` reader - "]
        pub type TxserrR = crate::BitReader;
        #[doc = "Field `txserr` writer - "]
        pub type TxserrW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn arblost(&self) -> ArblostR {
                ArblostR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn busy(&self) -> BusyR {
                BusyR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn rnack(&self) -> RnackR {
                RnackR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn rxoverfl(&self) -> RxoverflR {
                RxoverflR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn txoverfl(&self) -> TxoverflR {
                TxoverflR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn txserr(&self) -> TxserrR {
                TxserrR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 1"]
            #[inline(always)]
            #[must_use]
            pub fn arblost(&mut self) -> ArblostW<I2cfifosrLsbSpec> {
                ArblostW::new(self, 1)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            #[must_use]
            pub fn busy(&mut self) -> BusyW<I2cfifosrLsbSpec> {
                BusyW::new(self, 3)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            #[must_use]
            pub fn rnack(&mut self) -> RnackW<I2cfifosrLsbSpec> {
                RnackW::new(self, 4)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            #[must_use]
            pub fn rxoverfl(&mut self) -> RxoverflW<I2cfifosrLsbSpec> {
                RxoverflW::new(self, 5)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            #[must_use]
            pub fn txoverfl(&mut self) -> TxoverflW<I2cfifosrLsbSpec> {
                TxoverflW::new(self, 6)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            #[must_use]
            pub fn txserr(&mut self) -> TxserrW<I2cfifosrLsbSpec> {
                TxserrW::new(self, 7)
            }
        }
        #[doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2cfifosr_lsb::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2cfifosr_lsb::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct I2cfifosrLsbSpec;
        impl crate::RegisterSpec for I2cfifosrLsbSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`i2cfifosr_lsb::R`](R) reader structure"]
        impl crate::Readable for I2cfifosrLsbSpec {}
        #[doc = "`write(|w| ..)` method takes [`i2cfifosr_lsb::W`](W) writer structure"]
        impl crate::Writable for I2cfifosrLsbSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets I2CFIFOSR_LSB to value 0"]
        impl crate::Resettable for I2cfifosrLsbSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
    #[doc = "I2CFIFOSR_MSB (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2cfifosr_msb::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2cfifosr_msb::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@i2cfifosr_msb`]
module"]
    #[doc(alias = "I2CFIFOSR_MSB")]
    pub type I2cfifosrMsb = crate::Reg<i2cfifosr_msb::I2cfifosrMsbSpec>;
    #[doc = ""]
    pub mod i2cfifosr_msb {
        #[doc = "Register `I2CFIFOSR_MSB` reader"]
        pub type R = crate::R<I2cfifosrMsbSpec>;
        #[doc = "Register `I2CFIFOSR_MSB` writer"]
        pub type W = crate::W<I2cfifosrMsbSpec>;
        #[doc = "Field `rdcmpl` reader - "]
        pub type RdcmplR = crate::BitReader;
        #[doc = "Field `rdcmpl` writer - "]
        pub type RdcmplW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `perifrw` reader - "]
        pub type PerifrwR = crate::BitReader;
        #[doc = "Field `perifrw` writer - "]
        pub type PerifrwW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `txoverfl` reader - "]
        pub type TxoverflR = crate::BitReader;
        #[doc = "Field `txoverfl` writer - "]
        pub type TxoverflW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `rxunderfl` reader - "]
        pub type RxunderflR = crate::BitReader;
        #[doc = "Field `rxunderfl` writer - "]
        pub type RxunderflW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `bus_free` reader - "]
        pub type BusFreeR = crate::BitReader;
        #[doc = "Field `bus_free` writer - "]
        pub type BusFreeW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn rdcmpl(&self) -> RdcmplR {
                RdcmplR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn perifrw(&self) -> PerifrwR {
                PerifrwR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn txoverfl(&self) -> TxoverflR {
                TxoverflR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn rxunderfl(&self) -> RxunderflR {
                RxunderflR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn bus_free(&self) -> BusFreeR {
                BusFreeR::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            #[must_use]
            pub fn rdcmpl(&mut self) -> RdcmplW<I2cfifosrMsbSpec> {
                RdcmplW::new(self, 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            #[must_use]
            pub fn perifrw(&mut self) -> PerifrwW<I2cfifosrMsbSpec> {
                PerifrwW::new(self, 1)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            #[must_use]
            pub fn txoverfl(&mut self) -> TxoverflW<I2cfifosrMsbSpec> {
                TxoverflW::new(self, 2)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            #[must_use]
            pub fn rxunderfl(&mut self) -> RxunderflW<I2cfifosrMsbSpec> {
                RxunderflW::new(self, 3)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            #[must_use]
            pub fn bus_free(&mut self) -> BusFreeW<I2cfifosrMsbSpec> {
                BusFreeW::new(self, 4)
            }
        }
        #[doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2cfifosr_msb::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2cfifosr_msb::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct I2cfifosrMsbSpec;
        impl crate::RegisterSpec for I2cfifosrMsbSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`i2cfifosr_msb::R`](R) reader structure"]
        impl crate::Readable for I2cfifosrMsbSpec {}
        #[doc = "`write(|w| ..)` method takes [`i2cfifosr_msb::W`](W) writer structure"]
        impl crate::Writable for I2cfifosrMsbSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets I2CFIFOSR_MSB to value 0"]
        impl crate::Resettable for I2cfifosrMsbSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
    #[doc = "I2CTXFIFOBYTEAVAIL (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2ctxfifobyteavail::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2ctxfifobyteavail::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@i2ctxfifobyteavail`]
module"]
    #[doc(alias = "I2CTXFIFOBYTEAVAIL")]
    pub type I2ctxfifobyteavail = crate::Reg<i2ctxfifobyteavail::I2ctxfifobyteavailSpec>;
    #[doc = ""]
    pub mod i2ctxfifobyteavail {
        #[doc = "Register `I2CTXFIFOBYTEAVAIL` reader"]
        pub type R = crate::R<I2ctxfifobyteavailSpec>;
        #[doc = "Register `I2CTXFIFOBYTEAVAIL` writer"]
        pub type W = crate::W<I2ctxfifobyteavailSpec>;
        #[doc = "Field `dfirst` reader - "]
        pub type DfirstR = crate::BitReader;
        #[doc = "Field `dfirst` writer - "]
        pub type DfirstW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn dfirst(&self) -> DfirstR {
                DfirstR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            #[must_use]
            pub fn dfirst(&mut self) -> DfirstW<I2ctxfifobyteavailSpec> {
                DfirstW::new(self, 0)
            }
        }
        #[doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2ctxfifobyteavail::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2ctxfifobyteavail::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct I2ctxfifobyteavailSpec;
        impl crate::RegisterSpec for I2ctxfifobyteavailSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`i2ctxfifobyteavail::R`](R) reader structure"]
        impl crate::Readable for I2ctxfifobyteavailSpec {}
        #[doc = "`write(|w| ..)` method takes [`i2ctxfifobyteavail::W`](W) writer structure"]
        impl crate::Writable for I2ctxfifobyteavailSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets I2CTXFIFOBYTEAVAIL to value 0"]
        impl crate::Resettable for I2ctxfifobyteavailSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "uart0"]
    pub uart0: Uart0,
    #[doc = "timer0"]
    pub timer0: Timer0,
    #[doc = "I2CFIFO"]
    pub i2cfifo: I2cfifo,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            uart0: Uart0 {
                _marker: PhantomData,
            },
            timer0: Timer0 {
                _marker: PhantomData,
            },
            i2cfifo: I2cfifo {
                _marker: PhantomData,
            },
        }
    }
}
