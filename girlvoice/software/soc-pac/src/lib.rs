#![doc = "Peripheral access API for SOC microcontrollers (generated using svd2rust v0.33.3 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.33.3/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic {
    use core::marker;
    #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)"]
    pub trait RawReg:
        Copy
        + Default
        + From<bool>
        + core::ops::BitOr<Output = Self>
        + core::ops::BitAnd<Output = Self>
        + core::ops::BitOrAssign
        + core::ops::BitAndAssign
        + core::ops::Not<Output = Self>
        + core::ops::Shl<u8, Output = Self>
    {
        #[doc = " Mask for bits of width `WI`"]
        fn mask<const WI: u8>() -> Self;
        #[doc = " Mask for bits of width 1"]
        fn one() -> Self;
    }
    macro_rules! raw_reg {
        ($ U : ty , $ size : literal , $ mask : ident) => {
            impl RawReg for $U {
                #[inline(always)]
                fn mask<const WI: u8>() -> Self {
                    $mask::<WI>()
                }
                #[inline(always)]
                fn one() -> Self {
                    1
                }
            }
            const fn $mask<const WI: u8>() -> $U {
                <$U>::MAX >> ($size - WI)
            }
            impl FieldSpec for $U {
                type Ux = $U;
            }
        };
    }
    raw_reg!(u8, 8, mask_u8);
    raw_reg!(u16, 16, mask_u16);
    raw_reg!(u32, 32, mask_u32);
    raw_reg!(u64, 64, mask_u64);
    #[doc = " Raw register type"]
    pub trait RegisterSpec {
        #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
        type Ux: RawReg;
    }
    #[doc = " Raw field type"]
    pub trait FieldSpec: Sized {
        #[doc = " Raw field type (`u8`, `u16`, `u32`, ...)."]
        type Ux: Copy + core::fmt::Debug + PartialEq + From<Self>;
    }
    #[doc = " Marker for fields with fixed values"]
    pub trait IsEnum: FieldSpec {}
    #[doc = " Trait implemented by readable registers to enable the `read` method."]
    #[doc = ""]
    #[doc = " Registers marked with `Writable` can be also be `modify`'ed."]
    pub trait Readable: RegisterSpec {}
    #[doc = " Trait implemented by writeable registers."]
    #[doc = ""]
    #[doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
    #[doc = ""]
    #[doc = " Registers marked with `Readable` can be also be `modify`'ed."]
    pub trait Writable: RegisterSpec {
        #[doc = " Is it safe to write any bits to register"]
        type Safety;
        #[doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"]
        const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux;
        #[doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"]
        const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux;
    }
    #[doc = " Reset value of the register."]
    #[doc = ""]
    #[doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
    #[doc = " register by using the `reset` method."]
    pub trait Resettable: RegisterSpec {
        #[doc = " Reset value of the register."]
        const RESET_VALUE: Self::Ux;
        #[doc = " Reset value of the register."]
        #[inline(always)]
        fn reset_value() -> Self::Ux {
            Self::RESET_VALUE
        }
    }
    #[doc = " This structure provides volatile access to registers."]
    #[repr(transparent)]
    pub struct Reg<REG: RegisterSpec> {
        register: vcell::VolatileCell<REG::Ux>,
        _marker: marker::PhantomData<REG>,
    }
    unsafe impl<REG: RegisterSpec> Send for Reg<REG> where REG::Ux: Send {}
    impl<REG: RegisterSpec> Reg<REG> {
        #[doc = " Returns the underlying memory address of register."]
        #[doc = ""]
        #[doc = " ```ignore"]
        #[doc = " let reg_ptr = periph.reg.as_ptr();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn as_ptr(&self) -> *mut REG::Ux {
            self.register.as_ptr()
        }
    }
    impl<REG: Readable> Reg<REG> {
        #[doc = " Reads the contents of a `Readable` register."]
        #[doc = ""]
        #[doc = " You can read the raw contents of a register by using `bits`:"]
        #[doc = " ```ignore"]
        #[doc = " let bits = periph.reg.read().bits();"]
        #[doc = " ```"]
        #[doc = " or get the content of a particular field of a register:"]
        #[doc = " ```ignore"]
        #[doc = " let reader = periph.reg.read();"]
        #[doc = " let bits = reader.field1().bits();"]
        #[doc = " let flag = reader.field2().bit_is_set();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn read(&self) -> R<REG> {
            R {
                bits: self.register.get(),
                _reg: marker::PhantomData,
            }
        }
    }
    impl<REG: Resettable + Writable> Reg<REG> {
        #[doc = " Writes the reset value to `Writable` register."]
        #[doc = ""]
        #[doc = " Resets the register to its initial state."]
        #[inline(always)]
        pub fn reset(&self) {
            self.register.set(REG::RESET_VALUE)
        }
        #[doc = " Writes bits to a `Writable` register."]
        #[doc = ""]
        #[doc = " You can write raw bits into a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
        #[doc = " ```"]
        #[doc = " or write only the fields you need:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " In the latter case, other fields will be set to their reset value."]
        #[inline(always)]
        pub fn write<F>(&self, f: F)
        where
            F: FnOnce(&mut W<REG>) -> &mut W<REG>,
        {
            self.register.set(
                f(&mut W {
                    bits: REG::RESET_VALUE & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                        | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                    _reg: marker::PhantomData,
                })
                .bits,
            );
        }
    }
    impl<REG: Writable> Reg<REG> {
        #[doc = " Writes 0 to a `Writable` register."]
        #[doc = ""]
        #[doc = " Similar to `write`, but unused bits will contain 0."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Unsafe to use with registers which don't allow to write 0."]
        #[inline(always)]
        pub unsafe fn write_with_zero<F>(&self, f: F)
        where
            F: FnOnce(&mut W<REG>) -> &mut W<REG>,
        {
            self.register.set(
                f(&mut W {
                    bits: REG::Ux::default(),
                    _reg: marker::PhantomData,
                })
                .bits,
            );
        }
    }
    impl<REG: Readable + Writable> Reg<REG> {
        #[doc = " Modifies the contents of the register by reading and then writing it."]
        #[doc = ""]
        #[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
        #[doc = "    r.bits() | 3"]
        #[doc = " ) });"]
        #[doc = " ```"]
        #[doc = " or"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " Other fields will have the value they had before the call to `modify`."]
        #[inline(always)]
        pub fn modify<F>(&self, f: F)
        where
            for<'w> F: FnOnce(&R<REG>, &'w mut W<REG>) -> &'w mut W<REG>,
        {
            let bits = self.register.get();
            self.register.set(
                f(
                    &R {
                        bits,
                        _reg: marker::PhantomData,
                    },
                    &mut W {
                        bits: bits & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                            | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                        _reg: marker::PhantomData,
                    },
                )
                .bits,
            );
        }
    }
    impl<REG: Readable> core::fmt::Debug for crate::generic::Reg<REG>
    where
        R<REG>: core::fmt::Debug,
    {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            core::fmt::Debug::fmt(&self.read(), f)
        }
    }
    #[doc(hidden)]
    pub mod raw {
        use super::{marker, BitM, FieldSpec, RegisterSpec, Unsafe, Writable};
        pub struct R<REG: RegisterSpec> {
            pub(crate) bits: REG::Ux,
            pub(super) _reg: marker::PhantomData<REG>,
        }
        pub struct W<REG: RegisterSpec> {
            #[doc = "Writable bits"]
            pub(crate) bits: REG::Ux,
            pub(super) _reg: marker::PhantomData<REG>,
        }
        pub struct FieldReader<FI = u8>
        where
            FI: FieldSpec,
        {
            pub(crate) bits: FI::Ux,
            _reg: marker::PhantomData<FI>,
        }
        impl<FI: FieldSpec> FieldReader<FI> {
            #[doc = " Creates a new instance of the reader."]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) const fn new(bits: FI::Ux) -> Self {
                Self {
                    bits,
                    _reg: marker::PhantomData,
                }
            }
        }
        pub struct BitReader<FI = bool> {
            pub(crate) bits: bool,
            _reg: marker::PhantomData<FI>,
        }
        impl<FI> BitReader<FI> {
            #[doc = " Creates a new instance of the reader."]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) const fn new(bits: bool) -> Self {
                Self {
                    bits,
                    _reg: marker::PhantomData,
                }
            }
        }
        pub struct FieldWriter<'a, REG, const WI: u8, FI = u8, Safety = Unsafe>
        where
            REG: Writable + RegisterSpec,
            FI: FieldSpec,
        {
            pub(crate) w: &'a mut W<REG>,
            pub(crate) o: u8,
            _field: marker::PhantomData<(FI, Safety)>,
        }
        impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
        where
            REG: Writable + RegisterSpec,
            FI: FieldSpec,
        {
            #[doc = " Creates a new instance of the writer"]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) fn new(w: &'a mut W<REG>, o: u8) -> Self {
                Self {
                    w,
                    o,
                    _field: marker::PhantomData,
                }
            }
        }
        pub struct BitWriter<'a, REG, FI = bool, M = BitM>
        where
            REG: Writable + RegisterSpec,
            bool: From<FI>,
        {
            pub(crate) w: &'a mut W<REG>,
            pub(crate) o: u8,
            _field: marker::PhantomData<(FI, M)>,
        }
        impl<'a, REG, FI, M> BitWriter<'a, REG, FI, M>
        where
            REG: Writable + RegisterSpec,
            bool: From<FI>,
        {
            #[doc = " Creates a new instance of the writer"]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) fn new(w: &'a mut W<REG>, o: u8) -> Self {
                Self {
                    w,
                    o,
                    _field: marker::PhantomData,
                }
            }
        }
    }
    #[doc = " Register reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
    #[doc = " method."]
    pub type R<REG> = raw::R<REG>;
    impl<REG: RegisterSpec> R<REG> {
        #[doc = " Reads raw bits from register."]
        #[inline(always)]
        pub const fn bits(&self) -> REG::Ux {
            self.bits
        }
    }
    impl<REG: RegisterSpec, FI> PartialEq<FI> for R<REG>
    where
        REG::Ux: PartialEq,
        FI: Copy,
        REG::Ux: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&REG::Ux::from(*other))
        }
    }
    #[doc = " Register writer."]
    #[doc = ""]
    #[doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
    pub type W<REG> = raw::W<REG>;
    impl<REG: Writable> W<REG> {
        #[doc = " Writes raw bits to the register."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
        #[inline(always)]
        pub unsafe fn bits(&mut self, bits: REG::Ux) -> &mut Self {
            self.bits = bits;
            self
        }
    }
    impl<REG> W<REG>
    where
        REG: Writable<Safety = Safe>,
    {
        #[doc = " Writes raw bits to the register."]
        #[inline(always)]
        pub fn set(&mut self, bits: REG::Ux) -> &mut Self {
            self.bits = bits;
            self
        }
    }
    #[doc = " Field reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of fields."]
    pub type FieldReader<FI = u8> = raw::FieldReader<FI>;
    #[doc = " Bit-wise field reader"]
    pub type BitReader<FI = bool> = raw::BitReader<FI>;
    impl<FI: FieldSpec> FieldReader<FI> {
        #[doc = " Reads raw bits from field."]
        #[inline(always)]
        pub const fn bits(&self) -> FI::Ux {
            self.bits
        }
    }
    impl<FI: FieldSpec> core::fmt::Debug for FieldReader<FI> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            core::fmt::Debug::fmt(&self.bits, f)
        }
    }
    impl<FI> PartialEq<FI> for FieldReader<FI>
    where
        FI: FieldSpec + Copy,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&FI::Ux::from(*other))
        }
    }
    impl<FI> PartialEq<FI> for BitReader<FI>
    where
        FI: Copy,
        bool: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&bool::from(*other))
        }
    }
    impl<FI> BitReader<FI> {
        #[doc = " Value of the field as raw bits."]
        #[inline(always)]
        pub const fn bit(&self) -> bool {
            self.bits
        }
        #[doc = " Returns `true` if the bit is clear (0)."]
        #[inline(always)]
        pub const fn bit_is_clear(&self) -> bool {
            !self.bit()
        }
        #[doc = " Returns `true` if the bit is set (1)."]
        #[inline(always)]
        pub const fn bit_is_set(&self) -> bool {
            self.bit()
        }
    }
    impl<FI> core::fmt::Debug for BitReader<FI> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            core::fmt::Debug::fmt(&self.bits, f)
        }
    }
    #[doc = " Marker for register/field writers which can take any value of specified width"]
    pub struct Safe;
    #[doc = " You should check that value is allowed to pass to register/field writer marked with this"]
    pub struct Unsafe;
    #[doc = " Marker for field writers are safe to write in specified inclusive range"]
    pub struct Range<const MIN: u64, const MAX: u64>;
    #[doc = " Marker for field writers are safe to write in specified inclusive range"]
    pub struct RangeFrom<const MIN: u64>;
    #[doc = " Marker for field writers are safe to write in specified inclusive range"]
    pub struct RangeTo<const MAX: u64>;
    #[doc = " Write field Proxy"]
    pub type FieldWriter<'a, REG, const WI: u8, FI = u8, Safety = Unsafe> =
        raw::FieldWriter<'a, REG, WI, FI, Safety>;
    impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
    {
        #[doc = " Field width"]
        pub const WIDTH: u8 = WI;
        #[doc = " Field width"]
        #[inline(always)]
        pub const fn width(&self) -> u8 {
            WI
        }
        #[doc = " Field offset"]
        #[inline(always)]
        pub const fn offset(&self) -> u8 {
            self.o
        }
    }
    impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
        #[inline(always)]
        pub unsafe fn bits(self, value: FI::Ux) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::mask::<WI>() << self.o);
            self.w.bits |= (REG::Ux::from(value) & REG::Ux::mask::<WI>()) << self.o;
            self.w
        }
    }
    impl<'a, REG, const WI: u8, FI> FieldWriter<'a, REG, WI, FI, Safe>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, const MIN: u64, const MAX: u64>
        FieldWriter<'a, REG, WI, FI, Range<MIN, MAX>>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
        u64: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            {
                let value = u64::from(value);
                assert!(value >= MIN && value <= MAX);
            }
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, const MIN: u64> FieldWriter<'a, REG, WI, FI, RangeFrom<MIN>>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
        u64: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            {
                let value = u64::from(value);
                assert!(value >= MIN);
            }
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, const MAX: u64> FieldWriter<'a, REG, WI, FI, RangeTo<MAX>>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
        u64: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            {
                let value = u64::from(value);
                assert!(value <= MAX);
            }
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
    where
        REG: Writable + RegisterSpec,
        FI: IsEnum,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Writes `variant` to the field"]
        #[inline(always)]
        pub fn variant(self, variant: FI) -> &'a mut W<REG> {
            unsafe { self.bits(FI::Ux::from(variant)) }
        }
    }
    macro_rules! bit_proxy {
        ($ writer : ident , $ mwv : ident) => {
            #[doc(hidden)]
            pub struct $mwv;
            #[doc = " Bit-wise write field proxy"]
            pub type $writer<'a, REG, FI = bool> = raw::BitWriter<'a, REG, FI, $mwv>;
            impl<'a, REG, FI> $writer<'a, REG, FI>
            where
                REG: Writable + RegisterSpec,
                bool: From<FI>,
            {
                #[doc = " Field width"]
                pub const WIDTH: u8 = 1;
                #[doc = " Field width"]
                #[inline(always)]
                pub const fn width(&self) -> u8 {
                    Self::WIDTH
                }
                #[doc = " Field offset"]
                #[inline(always)]
                pub const fn offset(&self) -> u8 {
                    self.o
                }
                #[doc = " Writes bit to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W<REG> {
                    self.w.bits &= !(REG::Ux::one() << self.o);
                    self.w.bits |= (REG::Ux::from(value) & REG::Ux::one()) << self.o;
                    self.w
                }
                #[doc = " Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: FI) -> &'a mut W<REG> {
                    self.bit(bool::from(variant))
                }
            }
        };
    }
    bit_proxy!(BitWriter, BitM);
    bit_proxy!(BitWriter1S, Bit1S);
    bit_proxy!(BitWriter0C, Bit0C);
    bit_proxy!(BitWriter1C, Bit1C);
    bit_proxy!(BitWriter0S, Bit0S);
    bit_proxy!(BitWriter1T, Bit1T);
    bit_proxy!(BitWriter0T, Bit0T);
    impl<'a, REG, FI> BitWriter<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::one() << self.o;
            self.w
        }
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::one() << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1S<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::one() << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0C<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::one() << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1C<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Clears the field bit by passing one"]
        #[inline(always)]
        pub fn clear_bit_by_one(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::one() << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0S<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Sets the field bit by passing zero"]
        #[inline(always)]
        pub fn set_bit_by_zero(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::one() << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1T<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing one"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::one() << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0T<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing zero"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::one() << self.o);
            self.w
        }
    }
}
#[cfg(feature = "rt")]
extern "C" {
    fn timer0();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    pub _handler: unsafe extern "C" fn(),
    pub _reserved: usize,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[no_mangle]
pub static __EXTERNAL_INTERRUPTS: [Vector; 1] = [Vector { _handler: timer0 }];
#[doc(hidden)]
pub mod interrupt {
    #[doc = r"Enumeration of all the interrupts."]
    #[derive(Copy, Clone, Debug, PartialEq, Eq)]
    #[repr(u16)]
    pub enum Interrupt {
        #[doc = "0 - timer0"]
        timer0 = 0,
    }
    #[doc = r" TryFromInterruptError"]
    #[derive(Debug, Copy, Clone)]
    pub struct TryFromInterruptError(());
    impl Interrupt {
        #[doc = r" Attempt to convert a given value into an `Interrupt`"]
        #[inline]
        pub fn try_from(value: u8) -> Result<Self, TryFromInterruptError> {
            match value {
                0 => Ok(Interrupt::timer0),
                _ => Err(TryFromInterruptError(())),
            }
        }
    }
    #[cfg(feature = "rt")]
    #[macro_export]
    #[doc = r" Assigns a handler to an interrupt"]
    #[doc = r""]
    #[doc = r" This macro takes two arguments: the name of an interrupt and the path to the"]
    #[doc = r" function that will be used as the handler of that interrupt. That function"]
    #[doc = r" must have signature `fn()`."]
    #[doc = r""]
    #[doc = r" Optionally, a third argument may be used to declare interrupt local data."]
    #[doc = r" The handler will have exclusive access to these *local* variables on each"]
    #[doc = r" invocation. If the third argument is used then the signature of the handler"]
    #[doc = r" function must be `fn(&mut $NAME::Locals)` where `$NAME` is the first argument"]
    #[doc = r" passed to the macro."]
    #[doc = r""]
    #[doc = r" # Example"]
    #[doc = r""]
    #[doc = r" ``` ignore"]
    #[doc = r" interrupt!(TIM2, periodic);"]
    #[doc = r""]
    #[doc = r" fn periodic() {"]
    #[doc = r#"     print!(".");"#]
    #[doc = r" }"]
    #[doc = r""]
    #[doc = r" interrupt!(TIM3, tick, locals: {"]
    #[doc = r"     tick: bool = false;"]
    #[doc = r" });"]
    #[doc = r""]
    #[doc = r" fn tick(locals: &mut TIM3::Locals) {"]
    #[doc = r"     locals.tick = !locals.tick;"]
    #[doc = r""]
    #[doc = r"     if locals.tick {"]
    #[doc = r#"         println!("Tick");"#]
    #[doc = r"     } else {"]
    #[doc = r#"         println!("Tock");"#]
    #[doc = r"     }"]
    #[doc = r" }"]
    #[doc = r" ```"]
    macro_rules ! interrupt { ($ NAME : ident , $ path : path , locals : { $ ($ lvar : ident : $ lty : ty = $ lval : expr ;) * }) => { # [allow (non_snake_case)]
mod $ NAME { pub struct Locals { $ (pub $ lvar : $ lty ,) * } } # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; static mut LOCALS : self :: $ NAME :: Locals = self :: $ NAME :: Locals { $ ($ lvar : $ lval ,) * } ; let f : fn (& mut self :: $ NAME :: Locals) = $ path ; f (unsafe { & mut LOCALS }) ; } } ; ($ NAME : ident , $ path : path) => { # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; let f : fn () = $ path ; f () ; } } }
}
pub use self::interrupt::Interrupt;
#[doc = "uart0"]
pub struct Uart0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart0 {}
impl Uart0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0xf000_0200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart0 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart0").finish()
    }
}
#[doc = "uart0"]
pub mod uart0 {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        tx_data: TxData,
        _reserved1: [u8; 0x03],
        rx_data: RxData,
        _reserved2: [u8; 0x03],
        tx_ready: TxReady,
        _reserved3: [u8; 0x03],
        rx_avail: RxAvail,
        _reserved4: [u8; 0x03],
        divisor: Divisor,
    }
    impl RegisterBlock {
        #[doc = "0x00 - A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
        #[inline(always)]
        pub const fn tx_data(&self) -> &TxData {
            &self.tx_data
        }
        #[doc = "0x04 - A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
        #[inline(always)]
        pub const fn rx_data(&self) -> &RxData {
            &self.rx_data
        }
        #[doc = "0x08 - A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
        #[inline(always)]
        pub const fn tx_ready(&self) -> &TxReady {
            &self.tx_ready
        }
        #[doc = "0x0c - A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
        #[inline(always)]
        pub const fn rx_avail(&self) -> &RxAvail {
            &self.rx_avail
        }
        #[doc = "0x10 - A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
        #[inline(always)]
        pub const fn divisor(&self) -> &Divisor {
            &self.divisor
        }
    }
    #[doc = "tx_data (rw) register accessor: A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`tx_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tx_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tx_data`]
module"]
    #[doc(alias = "tx_data")]
    pub type TxData = crate::Reg<tx_data::TxDataSpec>;
    #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
    pub mod tx_data {
        #[doc = "Register `tx_data` reader"]
        pub type R = crate::R<TxDataSpec>;
        #[doc = "Register `tx_data` writer"]
        pub type W = crate::W<TxDataSpec>;
        #[doc = "Field `data` writer - data field"]
        pub type DataW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl W {
            #[doc = "Bits 0:7 - data field"]
            #[inline(always)]
            #[must_use]
            pub fn data(&mut self) -> DataW<TxDataSpec> {
                DataW::new(self, 0)
            }
        }
        #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`tx_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tx_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TxDataSpec;
        impl crate::RegisterSpec for TxDataSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`tx_data::R`](R) reader structure"]
        impl crate::Readable for TxDataSpec {}
        #[doc = "`write(|w| ..)` method takes [`tx_data::W`](W) writer structure"]
        impl crate::Writable for TxDataSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets tx_data to value 0"]
        impl crate::Resettable for TxDataSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
    #[doc = "rx_data (rw) register accessor: A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rx_data::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rx_data::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rx_data`]
module"]
    #[doc(alias = "rx_data")]
    pub type RxData = crate::Reg<rx_data::RxDataSpec>;
    #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
    pub mod rx_data {
        #[doc = "Register `rx_data` reader"]
        pub type R = crate::R<RxDataSpec>;
        #[doc = "Register `rx_data` writer"]
        pub type W = crate::W<RxDataSpec>;
        #[doc = "Field `data` reader - data field"]
        pub type DataR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - data field"]
            #[inline(always)]
            pub fn data(&self) -> DataR {
                DataR::new(self.bits)
            }
        }
        impl W {}
        #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rx_data::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rx_data::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RxDataSpec;
        impl crate::RegisterSpec for RxDataSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`rx_data::R`](R) reader structure"]
        impl crate::Readable for RxDataSpec {}
        #[doc = "`write(|w| ..)` method takes [`rx_data::W`](W) writer structure"]
        impl crate::Writable for RxDataSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets rx_data to value 0"]
        impl crate::Resettable for RxDataSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
    #[doc = "tx_ready (rw) register accessor: A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`tx_ready::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tx_ready::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tx_ready`]
module"]
    #[doc(alias = "tx_ready")]
    pub type TxReady = crate::Reg<tx_ready::TxReadySpec>;
    #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
    pub mod tx_ready {
        #[doc = "Register `tx_ready` reader"]
        pub type R = crate::R<TxReadySpec>;
        #[doc = "Register `tx_ready` writer"]
        pub type W = crate::W<TxReadySpec>;
        #[doc = "Field `txe` reader - txe field"]
        pub type TxeR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - txe field"]
            #[inline(always)]
            pub fn txe(&self) -> TxeR {
                TxeR::new((self.bits & 1) != 0)
            }
        }
        impl W {}
        #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`tx_ready::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tx_ready::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TxReadySpec;
        impl crate::RegisterSpec for TxReadySpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`tx_ready::R`](R) reader structure"]
        impl crate::Readable for TxReadySpec {}
        #[doc = "`write(|w| ..)` method takes [`tx_ready::W`](W) writer structure"]
        impl crate::Writable for TxReadySpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets tx_ready to value 0"]
        impl crate::Resettable for TxReadySpec {
            const RESET_VALUE: u8 = 0;
        }
    }
    #[doc = "rx_avail (rw) register accessor: A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rx_avail::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rx_avail::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rx_avail`]
module"]
    #[doc(alias = "rx_avail")]
    pub type RxAvail = crate::Reg<rx_avail::RxAvailSpec>;
    #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
    pub mod rx_avail {
        #[doc = "Register `rx_avail` reader"]
        pub type R = crate::R<RxAvailSpec>;
        #[doc = "Register `rx_avail` writer"]
        pub type W = crate::W<RxAvailSpec>;
        #[doc = "Field `rxe` reader - rxe field"]
        pub type RxeR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - rxe field"]
            #[inline(always)]
            pub fn rxe(&self) -> RxeR {
                RxeR::new((self.bits & 1) != 0)
            }
        }
        impl W {}
        #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rx_avail::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rx_avail::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RxAvailSpec;
        impl crate::RegisterSpec for RxAvailSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`rx_avail::R`](R) reader structure"]
        impl crate::Readable for RxAvailSpec {}
        #[doc = "`write(|w| ..)` method takes [`rx_avail::W`](W) writer structure"]
        impl crate::Writable for RxAvailSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets rx_avail to value 0"]
        impl crate::Resettable for RxAvailSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
    #[doc = "divisor (rw) register accessor: A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`divisor::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`divisor::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@divisor`]
module"]
    #[doc(alias = "divisor")]
    pub type Divisor = crate::Reg<divisor::DivisorSpec>;
    #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
    pub mod divisor {
        #[doc = "Register `divisor` reader"]
        pub type R = crate::R<DivisorSpec>;
        #[doc = "Register `divisor` writer"]
        pub type W = crate::W<DivisorSpec>;
        #[doc = "Field `div` reader - div field"]
        pub type DivR = crate::FieldReader<u32>;
        #[doc = "Field `div` writer - div field"]
        pub type DivW<'a, REG> = crate::FieldWriter<'a, REG, 24, u32>;
        impl R {
            #[doc = "Bits 0:23 - div field"]
            #[inline(always)]
            pub fn div(&self) -> DivR {
                DivR::new(self.bits & 0x00ff_ffff)
            }
        }
        impl W {
            #[doc = "Bits 0:23 - div field"]
            #[inline(always)]
            #[must_use]
            pub fn div(&mut self) -> DivW<DivisorSpec> {
                DivW::new(self, 0)
            }
        }
        #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`divisor::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`divisor::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DivisorSpec;
        impl crate::RegisterSpec for DivisorSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`divisor::R`](R) reader structure"]
        impl crate::Readable for DivisorSpec {}
        #[doc = "`write(|w| ..)` method takes [`divisor::W`](W) writer structure"]
        impl crate::Writable for DivisorSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets divisor to value 0"]
        impl crate::Resettable for DivisorSpec {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[doc = "timer0"]
pub struct Timer0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer0 {}
impl Timer0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer0::RegisterBlock = 0xf000_0300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer0 {
    type Target = timer0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer0").finish()
    }
}
#[doc = "timer0"]
pub mod timer0 {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        enable: Enable,
        mode: Mode,
        _reserved2: [u8; 0x02],
        reload: Reload,
        counter: Counter,
        _reserved4: [u8; 0x04],
        ev_enable: EvEnable,
        ev_pending: EvPending,
    }
    impl RegisterBlock {
        #[doc = "0x00 - A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
        #[inline(always)]
        pub const fn enable(&self) -> &Enable {
            &self.enable
        }
        #[doc = "0x01 - A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
        #[inline(always)]
        pub const fn mode(&self) -> &Mode {
            &self.mode
        }
        #[doc = "0x04 - A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
        #[inline(always)]
        pub const fn reload(&self) -> &Reload {
            &self.reload
        }
        #[doc = "0x08 - A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
        #[inline(always)]
        pub const fn counter(&self) -> &Counter {
            &self.counter
        }
        #[doc = "0x10 - A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
        #[inline(always)]
        pub const fn ev_enable(&self) -> &EvEnable {
            &self.ev_enable
        }
        #[doc = "0x11 - A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
        #[inline(always)]
        pub const fn ev_pending(&self) -> &EvPending {
            &self.ev_pending
        }
    }
    #[doc = "enable (rw) register accessor: A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`enable::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`enable::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@enable`]
module"]
    #[doc(alias = "enable")]
    pub type Enable = crate::Reg<enable::EnableSpec>;
    #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
    pub mod enable {
        #[doc = "Register `enable` reader"]
        pub type R = crate::R<EnableSpec>;
        #[doc = "Register `enable` writer"]
        pub type W = crate::W<EnableSpec>;
        #[doc = "Field `enable` reader - enable field"]
        pub type EnableR = crate::BitReader;
        #[doc = "Field `enable` writer - enable field"]
        pub type EnableW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - enable field"]
            #[inline(always)]
            pub fn enable(&self) -> EnableR {
                EnableR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - enable field"]
            #[inline(always)]
            #[must_use]
            pub fn enable(&mut self) -> EnableW<EnableSpec> {
                EnableW::new(self, 0)
            }
        }
        #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`enable::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`enable::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct EnableSpec;
        impl crate::RegisterSpec for EnableSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`enable::R`](R) reader structure"]
        impl crate::Readable for EnableSpec {}
        #[doc = "`write(|w| ..)` method takes [`enable::W`](W) writer structure"]
        impl crate::Writable for EnableSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets enable to value 0"]
        impl crate::Resettable for EnableSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
    #[doc = "mode (rw) register accessor: A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`mode::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mode::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mode`]
module"]
    #[doc(alias = "mode")]
    pub type Mode = crate::Reg<mode::ModeSpec>;
    #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
    pub mod mode {
        #[doc = "Register `mode` reader"]
        pub type R = crate::R<ModeSpec>;
        #[doc = "Register `mode` writer"]
        pub type W = crate::W<ModeSpec>;
        #[doc = "Field `periodic` reader - periodic field"]
        pub type PeriodicR = crate::BitReader;
        #[doc = "Field `periodic` writer - periodic field"]
        pub type PeriodicW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - periodic field"]
            #[inline(always)]
            pub fn periodic(&self) -> PeriodicR {
                PeriodicR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - periodic field"]
            #[inline(always)]
            #[must_use]
            pub fn periodic(&mut self) -> PeriodicW<ModeSpec> {
                PeriodicW::new(self, 0)
            }
        }
        #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`mode::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mode::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ModeSpec;
        impl crate::RegisterSpec for ModeSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`mode::R`](R) reader structure"]
        impl crate::Readable for ModeSpec {}
        #[doc = "`write(|w| ..)` method takes [`mode::W`](W) writer structure"]
        impl crate::Writable for ModeSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets mode to value 0"]
        impl crate::Resettable for ModeSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
    #[doc = "reload (rw) register accessor: A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`reload::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`reload::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reload`]
module"]
    #[doc(alias = "reload")]
    pub type Reload = crate::Reg<reload::ReloadSpec>;
    #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
    pub mod reload {
        #[doc = "Register `reload` reader"]
        pub type R = crate::R<ReloadSpec>;
        #[doc = "Register `reload` writer"]
        pub type W = crate::W<ReloadSpec>;
        #[doc = "Field `value` reader - value field"]
        pub type ValueR = crate::FieldReader<u32>;
        #[doc = "Field `value` writer - value field"]
        pub type ValueW<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - value field"]
            #[inline(always)]
            pub fn value(&self) -> ValueR {
                ValueR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - value field"]
            #[inline(always)]
            #[must_use]
            pub fn value(&mut self) -> ValueW<ReloadSpec> {
                ValueW::new(self, 0)
            }
        }
        #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`reload::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`reload::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ReloadSpec;
        impl crate::RegisterSpec for ReloadSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`reload::R`](R) reader structure"]
        impl crate::Readable for ReloadSpec {}
        #[doc = "`write(|w| ..)` method takes [`reload::W`](W) writer structure"]
        impl crate::Writable for ReloadSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets reload to value 0"]
        impl crate::Resettable for ReloadSpec {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "counter (rw) register accessor: A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`counter::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`counter::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@counter`]
module"]
    #[doc(alias = "counter")]
    pub type Counter = crate::Reg<counter::CounterSpec>;
    #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
    pub mod counter {
        #[doc = "Register `counter` reader"]
        pub type R = crate::R<CounterSpec>;
        #[doc = "Register `counter` writer"]
        pub type W = crate::W<CounterSpec>;
        #[doc = "Field `value` reader - value field"]
        pub type ValueR = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:31 - value field"]
            #[inline(always)]
            pub fn value(&self) -> ValueR {
                ValueR::new(self.bits)
            }
        }
        impl W {}
        #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`counter::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`counter::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CounterSpec;
        impl crate::RegisterSpec for CounterSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`counter::R`](R) reader structure"]
        impl crate::Readable for CounterSpec {}
        #[doc = "`write(|w| ..)` method takes [`counter::W`](W) writer structure"]
        impl crate::Writable for CounterSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets counter to value 0"]
        impl crate::Resettable for CounterSpec {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ev_enable (rw) register accessor: A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_enable::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_enable::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ev_enable`]
module"]
    #[doc(alias = "ev_enable")]
    pub type EvEnable = crate::Reg<ev_enable::EvEnableSpec>;
    #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
    pub mod ev_enable {
        #[doc = "Register `ev_enable` reader"]
        pub type R = crate::R<EvEnableSpec>;
        #[doc = "Register `ev_enable` writer"]
        pub type W = crate::W<EvEnableSpec>;
        #[doc = "Field `mask` reader - mask field"]
        pub type MaskR = crate::BitReader;
        #[doc = "Field `mask` writer - mask field"]
        pub type MaskW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - mask field"]
            #[inline(always)]
            pub fn mask(&self) -> MaskR {
                MaskR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - mask field"]
            #[inline(always)]
            #[must_use]
            pub fn mask(&mut self) -> MaskW<EvEnableSpec> {
                MaskW::new(self, 0)
            }
        }
        #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_enable::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_enable::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct EvEnableSpec;
        impl crate::RegisterSpec for EvEnableSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`ev_enable::R`](R) reader structure"]
        impl crate::Readable for EvEnableSpec {}
        #[doc = "`write(|w| ..)` method takes [`ev_enable::W`](W) writer structure"]
        impl crate::Writable for EvEnableSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets ev_enable to value 0"]
        impl crate::Resettable for EvEnableSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
    #[doc = "ev_pending (rw) register accessor: A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_pending::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_pending::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ev_pending`]
module"]
    #[doc(alias = "ev_pending")]
    pub type EvPending = crate::Reg<ev_pending::EvPendingSpec>;
    #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
    pub mod ev_pending {
        #[doc = "Register `ev_pending` reader"]
        pub type R = crate::R<EvPendingSpec>;
        #[doc = "Register `ev_pending` writer"]
        pub type W = crate::W<EvPendingSpec>;
        #[doc = "Field `mask` reader - mask field"]
        pub type MaskR = crate::BitReader;
        #[doc = "Field `mask` writer - mask field"]
        pub type MaskW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - mask field"]
            #[inline(always)]
            pub fn mask(&self) -> MaskR {
                MaskR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - mask field"]
            #[inline(always)]
            #[must_use]
            pub fn mask(&mut self) -> MaskW<EvPendingSpec> {
                MaskW::new(self, 0)
            }
        }
        #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_pending::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_pending::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct EvPendingSpec;
        impl crate::RegisterSpec for EvPendingSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`ev_pending::R`](R) reader structure"]
        impl crate::Readable for EvPendingSpec {}
        #[doc = "`write(|w| ..)` method takes [`ev_pending::W`](W) writer structure"]
        impl crate::Writable for EvPendingSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets ev_pending to value 0"]
        impl crate::Resettable for EvPendingSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
}
#[doc = "led0"]
pub struct Led0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Led0 {}
impl Led0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const led0::RegisterBlock = 0xf000_0500 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const led0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Led0 {
    type Target = led0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Led0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Led0").finish()
    }
}
#[doc = "led0"]
pub mod led0 {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        mode: Mode,
        input: Input,
        output: Output,
        set_clr: SetClr,
    }
    impl RegisterBlock {
        #[doc = "0x00 - A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
        #[inline(always)]
        pub const fn mode(&self) -> &Mode {
            &self.mode
        }
        #[doc = "0x01 - A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
        #[inline(always)]
        pub const fn input(&self) -> &Input {
            &self.input
        }
        #[doc = "0x02 - A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
        #[inline(always)]
        pub const fn output(&self) -> &Output {
            &self.output
        }
        #[doc = "0x03 - A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
        #[inline(always)]
        pub const fn set_clr(&self) -> &SetClr {
            &self.set_clr
        }
    }
    #[doc = "Mode (rw) register accessor: A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`mode::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mode::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mode`]
module"]
    pub type Mode = crate::Reg<mode::ModeSpec>;
    #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
    pub mod mode {
        #[doc = "Register `Mode` reader"]
        pub type R = crate::R<ModeSpec>;
        #[doc = "Register `Mode` writer"]
        pub type W = crate::W<ModeSpec>;
        #[doc = "Field `pin_0` reader - pin_0 field"]
        pub type Pin0R = crate::FieldReader;
        #[doc = "Field `pin_0` writer - pin_0 field"]
        pub type Pin0W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            #[doc = "Bits 0:1 - pin_0 field"]
            #[inline(always)]
            pub fn pin_0(&self) -> Pin0R {
                Pin0R::new(self.bits & 3)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - pin_0 field"]
            #[inline(always)]
            #[must_use]
            pub fn pin_0(&mut self) -> Pin0W<ModeSpec> {
                Pin0W::new(self, 0)
            }
        }
        #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`mode::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mode::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ModeSpec;
        impl crate::RegisterSpec for ModeSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`mode::R`](R) reader structure"]
        impl crate::Readable for ModeSpec {}
        #[doc = "`write(|w| ..)` method takes [`mode::W`](W) writer structure"]
        impl crate::Writable for ModeSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets Mode to value 0"]
        impl crate::Resettable for ModeSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
    #[doc = "Input (rw) register accessor: A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`input::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`input::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@input`]
module"]
    pub type Input = crate::Reg<input::InputSpec>;
    #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
    pub mod input {
        #[doc = "Register `Input` reader"]
        pub type R = crate::R<InputSpec>;
        #[doc = "Register `Input` writer"]
        pub type W = crate::W<InputSpec>;
        #[doc = "Field `pin_0` reader - pin_0 field"]
        pub type Pin0R = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - pin_0 field"]
            #[inline(always)]
            pub fn pin_0(&self) -> Pin0R {
                Pin0R::new((self.bits & 1) != 0)
            }
        }
        impl W {}
        #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`input::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`input::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct InputSpec;
        impl crate::RegisterSpec for InputSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`input::R`](R) reader structure"]
        impl crate::Readable for InputSpec {}
        #[doc = "`write(|w| ..)` method takes [`input::W`](W) writer structure"]
        impl crate::Writable for InputSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets Input to value 0"]
        impl crate::Resettable for InputSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
    #[doc = "Output (rw) register accessor: A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`output::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`output::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@output`]
module"]
    pub type Output = crate::Reg<output::OutputSpec>;
    #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
    pub mod output {
        #[doc = "Register `Output` reader"]
        pub type R = crate::R<OutputSpec>;
        #[doc = "Register `Output` writer"]
        pub type W = crate::W<OutputSpec>;
        #[doc = "Field `pin_0` reader - pin_0 field"]
        pub type Pin0R = crate::BitReader;
        #[doc = "Field `pin_0` writer - pin_0 field"]
        pub type Pin0W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - pin_0 field"]
            #[inline(always)]
            pub fn pin_0(&self) -> Pin0R {
                Pin0R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - pin_0 field"]
            #[inline(always)]
            #[must_use]
            pub fn pin_0(&mut self) -> Pin0W<OutputSpec> {
                Pin0W::new(self, 0)
            }
        }
        #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`output::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`output::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct OutputSpec;
        impl crate::RegisterSpec for OutputSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`output::R`](R) reader structure"]
        impl crate::Readable for OutputSpec {}
        #[doc = "`write(|w| ..)` method takes [`output::W`](W) writer structure"]
        impl crate::Writable for OutputSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets Output to value 0"]
        impl crate::Resettable for OutputSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
    #[doc = "SetClr (rw) register accessor: A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`set_clr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`set_clr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@set_clr`]
module"]
    pub type SetClr = crate::Reg<set_clr::SetClrSpec>;
    #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable."]
    pub mod set_clr {
        #[doc = "Register `SetClr` reader"]
        pub type R = crate::R<SetClrSpec>;
        #[doc = "Register `SetClr` writer"]
        pub type W = crate::W<SetClrSpec>;
        #[doc = "Field `pin_0_set` writer - pin_0_set field"]
        pub type Pin0SetW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `pin_0_clr` writer - pin_0_clr field"]
        pub type Pin0ClrW<'a, REG> = crate::BitWriter<'a, REG>;
        impl W {
            #[doc = "Bit 0 - pin_0_set field"]
            #[inline(always)]
            #[must_use]
            pub fn pin_0_set(&mut self) -> Pin0SetW<SetClrSpec> {
                Pin0SetW::new(self, 0)
            }
            #[doc = "Bit 1 - pin_0_clr field"]
            #[inline(always)]
            #[must_use]
            pub fn pin_0_clr(&mut self) -> Pin0ClrW<SetClrSpec> {
                Pin0ClrW::new(self, 1)
            }
        }
        #[doc = "A CSR register. Parameters ---------- fields : :class:`dict` or :class:`list` or :class:`Field` Collection of register fields. If ``None`` (default), a dict is populated from Python :term:`variable annotations &lt;python:variable annotations>`. ``fields`` is used to create a :class:`FieldActionMap`, :class:`FieldActionArray`, or :class:`FieldAction`, depending on its type (dict, list, or Field). Interface attributes -------------------- element : :class:`Element` Interface between this register and a CSR bus primitive. Attributes ---------- field : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Collection of field instances. f : :class:`FieldActionMap` or :class:`FieldActionArray` or :class:`FieldAction` Shorthand for :attr:`Register.field`. Raises ------ :exc:`TypeError` If ``fields`` is neither ``None``, a :class:`dict`, a :class:`list`, or a :class:`Field`. :exc:`ValueError` If ``fields`` is not ``None`` and at least one variable annotation is a :class:`Field`. :exc:`ValueError` If ``element.access`` is not readable and at least one field is readable. :exc:`ValueError` If ``element.access`` is not writable and at least one field is writable.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`set_clr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`set_clr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SetClrSpec;
        impl crate::RegisterSpec for SetClrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`set_clr::R`](R) reader structure"]
        impl crate::Readable for SetClrSpec {}
        #[doc = "`write(|w| ..)` method takes [`set_clr::W`](W) writer structure"]
        impl crate::Writable for SetClrSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets SetClr to value 0"]
        impl crate::Resettable for SetClrSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "uart0"]
    pub uart0: Uart0,
    #[doc = "timer0"]
    pub timer0: Timer0,
    #[doc = "led0"]
    pub led0: Led0,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            uart0: Uart0 {
                _marker: PhantomData,
            },
            timer0: Timer0 {
                _marker: PhantomData,
            },
            led0: Led0 {
                _marker: PhantomData,
            },
        }
    }
}
