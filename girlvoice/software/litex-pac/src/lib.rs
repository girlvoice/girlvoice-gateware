#![doc = "Peripheral access API for SOC microcontrollers (generated using svd2rust v0.33.3 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.33.3/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic {
    use core::marker;
    #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)"]
    pub trait RawReg:
        Copy
        + Default
        + From<bool>
        + core::ops::BitOr<Output = Self>
        + core::ops::BitAnd<Output = Self>
        + core::ops::BitOrAssign
        + core::ops::BitAndAssign
        + core::ops::Not<Output = Self>
        + core::ops::Shl<u8, Output = Self>
    {
        #[doc = " Mask for bits of width `WI`"]
        fn mask<const WI: u8>() -> Self;
        #[doc = " Mask for bits of width 1"]
        fn one() -> Self;
    }
    macro_rules! raw_reg {
        ($ U : ty , $ size : literal , $ mask : ident) => {
            impl RawReg for $U {
                #[inline(always)]
                fn mask<const WI: u8>() -> Self {
                    $mask::<WI>()
                }
                #[inline(always)]
                fn one() -> Self {
                    1
                }
            }
            const fn $mask<const WI: u8>() -> $U {
                <$U>::MAX >> ($size - WI)
            }
            impl FieldSpec for $U {
                type Ux = $U;
            }
        };
    }
    raw_reg!(u8, 8, mask_u8);
    raw_reg!(u16, 16, mask_u16);
    raw_reg!(u32, 32, mask_u32);
    raw_reg!(u64, 64, mask_u64);
    #[doc = " Raw register type"]
    pub trait RegisterSpec {
        #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
        type Ux: RawReg;
    }
    #[doc = " Raw field type"]
    pub trait FieldSpec: Sized {
        #[doc = " Raw field type (`u8`, `u16`, `u32`, ...)."]
        type Ux: Copy + core::fmt::Debug + PartialEq + From<Self>;
    }
    #[doc = " Marker for fields with fixed values"]
    pub trait IsEnum: FieldSpec {}
    #[doc = " Trait implemented by readable registers to enable the `read` method."]
    #[doc = ""]
    #[doc = " Registers marked with `Writable` can be also be `modify`'ed."]
    pub trait Readable: RegisterSpec {}
    #[doc = " Trait implemented by writeable registers."]
    #[doc = ""]
    #[doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
    #[doc = ""]
    #[doc = " Registers marked with `Readable` can be also be `modify`'ed."]
    pub trait Writable: RegisterSpec {
        #[doc = " Is it safe to write any bits to register"]
        type Safety;
        #[doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"]
        const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux;
        #[doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"]
        const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux;
    }
    #[doc = " Reset value of the register."]
    #[doc = ""]
    #[doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
    #[doc = " register by using the `reset` method."]
    pub trait Resettable: RegisterSpec {
        #[doc = " Reset value of the register."]
        const RESET_VALUE: Self::Ux;
        #[doc = " Reset value of the register."]
        #[inline(always)]
        fn reset_value() -> Self::Ux {
            Self::RESET_VALUE
        }
    }
    #[doc = " This structure provides volatile access to registers."]
    #[repr(transparent)]
    pub struct Reg<REG: RegisterSpec> {
        register: vcell::VolatileCell<REG::Ux>,
        _marker: marker::PhantomData<REG>,
    }
    unsafe impl<REG: RegisterSpec> Send for Reg<REG> where REG::Ux: Send {}
    impl<REG: RegisterSpec> Reg<REG> {
        #[doc = " Returns the underlying memory address of register."]
        #[doc = ""]
        #[doc = " ```ignore"]
        #[doc = " let reg_ptr = periph.reg.as_ptr();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn as_ptr(&self) -> *mut REG::Ux {
            self.register.as_ptr()
        }
    }
    impl<REG: Readable> Reg<REG> {
        #[doc = " Reads the contents of a `Readable` register."]
        #[doc = ""]
        #[doc = " You can read the raw contents of a register by using `bits`:"]
        #[doc = " ```ignore"]
        #[doc = " let bits = periph.reg.read().bits();"]
        #[doc = " ```"]
        #[doc = " or get the content of a particular field of a register:"]
        #[doc = " ```ignore"]
        #[doc = " let reader = periph.reg.read();"]
        #[doc = " let bits = reader.field1().bits();"]
        #[doc = " let flag = reader.field2().bit_is_set();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn read(&self) -> R<REG> {
            R {
                bits: self.register.get(),
                _reg: marker::PhantomData,
            }
        }
    }
    impl<REG: Resettable + Writable> Reg<REG> {
        #[doc = " Writes the reset value to `Writable` register."]
        #[doc = ""]
        #[doc = " Resets the register to its initial state."]
        #[inline(always)]
        pub fn reset(&self) {
            self.register.set(REG::RESET_VALUE)
        }
        #[doc = " Writes bits to a `Writable` register."]
        #[doc = ""]
        #[doc = " You can write raw bits into a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
        #[doc = " ```"]
        #[doc = " or write only the fields you need:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " In the latter case, other fields will be set to their reset value."]
        #[inline(always)]
        pub fn write<F>(&self, f: F)
        where
            F: FnOnce(&mut W<REG>) -> &mut W<REG>,
        {
            self.register.set(
                f(&mut W {
                    bits: REG::RESET_VALUE & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                        | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                    _reg: marker::PhantomData,
                })
                .bits,
            );
        }
    }
    impl<REG: Writable> Reg<REG> {
        #[doc = " Writes 0 to a `Writable` register."]
        #[doc = ""]
        #[doc = " Similar to `write`, but unused bits will contain 0."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Unsafe to use with registers which don't allow to write 0."]
        #[inline(always)]
        pub unsafe fn write_with_zero<F>(&self, f: F)
        where
            F: FnOnce(&mut W<REG>) -> &mut W<REG>,
        {
            self.register.set(
                f(&mut W {
                    bits: REG::Ux::default(),
                    _reg: marker::PhantomData,
                })
                .bits,
            );
        }
    }
    impl<REG: Readable + Writable> Reg<REG> {
        #[doc = " Modifies the contents of the register by reading and then writing it."]
        #[doc = ""]
        #[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
        #[doc = "    r.bits() | 3"]
        #[doc = " ) });"]
        #[doc = " ```"]
        #[doc = " or"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " Other fields will have the value they had before the call to `modify`."]
        #[inline(always)]
        pub fn modify<F>(&self, f: F)
        where
            for<'w> F: FnOnce(&R<REG>, &'w mut W<REG>) -> &'w mut W<REG>,
        {
            let bits = self.register.get();
            self.register.set(
                f(
                    &R {
                        bits,
                        _reg: marker::PhantomData,
                    },
                    &mut W {
                        bits: bits & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                            | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                        _reg: marker::PhantomData,
                    },
                )
                .bits,
            );
        }
    }
    impl<REG: Readable> core::fmt::Debug for crate::generic::Reg<REG>
    where
        R<REG>: core::fmt::Debug,
    {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            core::fmt::Debug::fmt(&self.read(), f)
        }
    }
    #[doc(hidden)]
    pub mod raw {
        use super::{marker, BitM, FieldSpec, RegisterSpec, Unsafe, Writable};
        pub struct R<REG: RegisterSpec> {
            pub(crate) bits: REG::Ux,
            pub(super) _reg: marker::PhantomData<REG>,
        }
        pub struct W<REG: RegisterSpec> {
            #[doc = "Writable bits"]
            pub(crate) bits: REG::Ux,
            pub(super) _reg: marker::PhantomData<REG>,
        }
        pub struct FieldReader<FI = u8>
        where
            FI: FieldSpec,
        {
            pub(crate) bits: FI::Ux,
            _reg: marker::PhantomData<FI>,
        }
        impl<FI: FieldSpec> FieldReader<FI> {
            #[doc = " Creates a new instance of the reader."]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) const fn new(bits: FI::Ux) -> Self {
                Self {
                    bits,
                    _reg: marker::PhantomData,
                }
            }
        }
        pub struct BitReader<FI = bool> {
            pub(crate) bits: bool,
            _reg: marker::PhantomData<FI>,
        }
        impl<FI> BitReader<FI> {
            #[doc = " Creates a new instance of the reader."]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) const fn new(bits: bool) -> Self {
                Self {
                    bits,
                    _reg: marker::PhantomData,
                }
            }
        }
        pub struct FieldWriter<'a, REG, const WI: u8, FI = u8, Safety = Unsafe>
        where
            REG: Writable + RegisterSpec,
            FI: FieldSpec,
        {
            pub(crate) w: &'a mut W<REG>,
            pub(crate) o: u8,
            _field: marker::PhantomData<(FI, Safety)>,
        }
        impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
        where
            REG: Writable + RegisterSpec,
            FI: FieldSpec,
        {
            #[doc = " Creates a new instance of the writer"]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) fn new(w: &'a mut W<REG>, o: u8) -> Self {
                Self {
                    w,
                    o,
                    _field: marker::PhantomData,
                }
            }
        }
        pub struct BitWriter<'a, REG, FI = bool, M = BitM>
        where
            REG: Writable + RegisterSpec,
            bool: From<FI>,
        {
            pub(crate) w: &'a mut W<REG>,
            pub(crate) o: u8,
            _field: marker::PhantomData<(FI, M)>,
        }
        impl<'a, REG, FI, M> BitWriter<'a, REG, FI, M>
        where
            REG: Writable + RegisterSpec,
            bool: From<FI>,
        {
            #[doc = " Creates a new instance of the writer"]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) fn new(w: &'a mut W<REG>, o: u8) -> Self {
                Self {
                    w,
                    o,
                    _field: marker::PhantomData,
                }
            }
        }
    }
    #[doc = " Register reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
    #[doc = " method."]
    pub type R<REG> = raw::R<REG>;
    impl<REG: RegisterSpec> R<REG> {
        #[doc = " Reads raw bits from register."]
        #[inline(always)]
        pub const fn bits(&self) -> REG::Ux {
            self.bits
        }
    }
    impl<REG: RegisterSpec, FI> PartialEq<FI> for R<REG>
    where
        REG::Ux: PartialEq,
        FI: Copy,
        REG::Ux: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&REG::Ux::from(*other))
        }
    }
    #[doc = " Register writer."]
    #[doc = ""]
    #[doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
    pub type W<REG> = raw::W<REG>;
    impl<REG: Writable> W<REG> {
        #[doc = " Writes raw bits to the register."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
        #[inline(always)]
        pub unsafe fn bits(&mut self, bits: REG::Ux) -> &mut Self {
            self.bits = bits;
            self
        }
    }
    impl<REG> W<REG>
    where
        REG: Writable<Safety = Safe>,
    {
        #[doc = " Writes raw bits to the register."]
        #[inline(always)]
        pub fn set(&mut self, bits: REG::Ux) -> &mut Self {
            self.bits = bits;
            self
        }
    }
    #[doc = " Field reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of fields."]
    pub type FieldReader<FI = u8> = raw::FieldReader<FI>;
    #[doc = " Bit-wise field reader"]
    pub type BitReader<FI = bool> = raw::BitReader<FI>;
    impl<FI: FieldSpec> FieldReader<FI> {
        #[doc = " Reads raw bits from field."]
        #[inline(always)]
        pub const fn bits(&self) -> FI::Ux {
            self.bits
        }
    }
    impl<FI: FieldSpec> core::fmt::Debug for FieldReader<FI> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            core::fmt::Debug::fmt(&self.bits, f)
        }
    }
    impl<FI> PartialEq<FI> for FieldReader<FI>
    where
        FI: FieldSpec + Copy,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&FI::Ux::from(*other))
        }
    }
    impl<FI> PartialEq<FI> for BitReader<FI>
    where
        FI: Copy,
        bool: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&bool::from(*other))
        }
    }
    impl<FI> BitReader<FI> {
        #[doc = " Value of the field as raw bits."]
        #[inline(always)]
        pub const fn bit(&self) -> bool {
            self.bits
        }
        #[doc = " Returns `true` if the bit is clear (0)."]
        #[inline(always)]
        pub const fn bit_is_clear(&self) -> bool {
            !self.bit()
        }
        #[doc = " Returns `true` if the bit is set (1)."]
        #[inline(always)]
        pub const fn bit_is_set(&self) -> bool {
            self.bit()
        }
    }
    impl<FI> core::fmt::Debug for BitReader<FI> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            core::fmt::Debug::fmt(&self.bits, f)
        }
    }
    #[doc = " Marker for register/field writers which can take any value of specified width"]
    pub struct Safe;
    #[doc = " You should check that value is allowed to pass to register/field writer marked with this"]
    pub struct Unsafe;
    #[doc = " Marker for field writers are safe to write in specified inclusive range"]
    pub struct Range<const MIN: u64, const MAX: u64>;
    #[doc = " Marker for field writers are safe to write in specified inclusive range"]
    pub struct RangeFrom<const MIN: u64>;
    #[doc = " Marker for field writers are safe to write in specified inclusive range"]
    pub struct RangeTo<const MAX: u64>;
    #[doc = " Write field Proxy"]
    pub type FieldWriter<'a, REG, const WI: u8, FI = u8, Safety = Unsafe> =
        raw::FieldWriter<'a, REG, WI, FI, Safety>;
    impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
    {
        #[doc = " Field width"]
        pub const WIDTH: u8 = WI;
        #[doc = " Field width"]
        #[inline(always)]
        pub const fn width(&self) -> u8 {
            WI
        }
        #[doc = " Field offset"]
        #[inline(always)]
        pub const fn offset(&self) -> u8 {
            self.o
        }
    }
    impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
        #[inline(always)]
        pub unsafe fn bits(self, value: FI::Ux) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::mask::<WI>() << self.o);
            self.w.bits |= (REG::Ux::from(value) & REG::Ux::mask::<WI>()) << self.o;
            self.w
        }
    }
    impl<'a, REG, const WI: u8, FI> FieldWriter<'a, REG, WI, FI, Safe>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, const MIN: u64, const MAX: u64>
        FieldWriter<'a, REG, WI, FI, Range<MIN, MAX>>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
        u64: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            {
                let value = u64::from(value);
                assert!(value >= MIN && value <= MAX);
            }
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, const MIN: u64> FieldWriter<'a, REG, WI, FI, RangeFrom<MIN>>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
        u64: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            {
                let value = u64::from(value);
                assert!(value >= MIN);
            }
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, const MAX: u64> FieldWriter<'a, REG, WI, FI, RangeTo<MAX>>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
        u64: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            {
                let value = u64::from(value);
                assert!(value <= MAX);
            }
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
    where
        REG: Writable + RegisterSpec,
        FI: IsEnum,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Writes `variant` to the field"]
        #[inline(always)]
        pub fn variant(self, variant: FI) -> &'a mut W<REG> {
            unsafe { self.bits(FI::Ux::from(variant)) }
        }
    }
    macro_rules! bit_proxy {
        ($ writer : ident , $ mwv : ident) => {
            #[doc(hidden)]
            pub struct $mwv;
            #[doc = " Bit-wise write field proxy"]
            pub type $writer<'a, REG, FI = bool> = raw::BitWriter<'a, REG, FI, $mwv>;
            impl<'a, REG, FI> $writer<'a, REG, FI>
            where
                REG: Writable + RegisterSpec,
                bool: From<FI>,
            {
                #[doc = " Field width"]
                pub const WIDTH: u8 = 1;
                #[doc = " Field width"]
                #[inline(always)]
                pub const fn width(&self) -> u8 {
                    Self::WIDTH
                }
                #[doc = " Field offset"]
                #[inline(always)]
                pub const fn offset(&self) -> u8 {
                    self.o
                }
                #[doc = " Writes bit to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W<REG> {
                    self.w.bits &= !(REG::Ux::one() << self.o);
                    self.w.bits |= (REG::Ux::from(value) & REG::Ux::one()) << self.o;
                    self.w
                }
                #[doc = " Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: FI) -> &'a mut W<REG> {
                    self.bit(bool::from(variant))
                }
            }
        };
    }
    bit_proxy!(BitWriter, BitM);
    bit_proxy!(BitWriter1S, Bit1S);
    bit_proxy!(BitWriter0C, Bit0C);
    bit_proxy!(BitWriter1C, Bit1C);
    bit_proxy!(BitWriter0S, Bit0S);
    bit_proxy!(BitWriter1T, Bit1T);
    bit_proxy!(BitWriter0T, Bit0T);
    impl<'a, REG, FI> BitWriter<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::one() << self.o;
            self.w
        }
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::one() << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1S<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::one() << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0C<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::one() << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1C<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Clears the field bit by passing one"]
        #[inline(always)]
        pub fn clear_bit_by_one(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::one() << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0S<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Sets the field bit by passing zero"]
        #[inline(always)]
        pub fn set_bit_by_zero(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::one() << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1T<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing one"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::one() << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0T<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing zero"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::one() << self.o);
            self.w
        }
    }
}
#[cfg(feature = "rt")]
extern "C" {
    fn uart();
    fn timer0();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    pub _handler: unsafe extern "C" fn(),
    pub _reserved: usize,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[no_mangle]
pub static __EXTERNAL_INTERRUPTS: [Vector; 2] =
    [Vector { _handler: uart }, Vector { _handler: timer0 }];
#[doc(hidden)]
pub mod interrupt {
    #[doc = r"Enumeration of all the interrupts."]
    #[derive(Copy, Clone, Debug, PartialEq, Eq)]
    #[repr(u16)]
    pub enum Interrupt {
        #[doc = "0 - uart"]
        uart = 0,
        #[doc = "1 - timer0"]
        timer0 = 1,
    }
    #[doc = r" TryFromInterruptError"]
    #[derive(Debug, Copy, Clone)]
    pub struct TryFromInterruptError(());
    impl Interrupt {
        #[doc = r" Attempt to convert a given value into an `Interrupt`"]
        #[inline]
        pub fn try_from(value: u8) -> Result<Self, TryFromInterruptError> {
            match value {
                0 => Ok(Interrupt::uart),
                1 => Ok(Interrupt::timer0),
                _ => Err(TryFromInterruptError(())),
            }
        }
    }
    #[cfg(feature = "rt")]
    #[macro_export]
    #[doc = r" Assigns a handler to an interrupt"]
    #[doc = r""]
    #[doc = r" This macro takes two arguments: the name of an interrupt and the path to the"]
    #[doc = r" function that will be used as the handler of that interrupt. That function"]
    #[doc = r" must have signature `fn()`."]
    #[doc = r""]
    #[doc = r" Optionally, a third argument may be used to declare interrupt local data."]
    #[doc = r" The handler will have exclusive access to these *local* variables on each"]
    #[doc = r" invocation. If the third argument is used then the signature of the handler"]
    #[doc = r" function must be `fn(&mut $NAME::Locals)` where `$NAME` is the first argument"]
    #[doc = r" passed to the macro."]
    #[doc = r""]
    #[doc = r" # Example"]
    #[doc = r""]
    #[doc = r" ``` ignore"]
    #[doc = r" interrupt!(TIM2, periodic);"]
    #[doc = r""]
    #[doc = r" fn periodic() {"]
    #[doc = r#"     print!(".");"#]
    #[doc = r" }"]
    #[doc = r""]
    #[doc = r" interrupt!(TIM3, tick, locals: {"]
    #[doc = r"     tick: bool = false;"]
    #[doc = r" });"]
    #[doc = r""]
    #[doc = r" fn tick(locals: &mut TIM3::Locals) {"]
    #[doc = r"     locals.tick = !locals.tick;"]
    #[doc = r""]
    #[doc = r"     if locals.tick {"]
    #[doc = r#"         println!("Tick");"#]
    #[doc = r"     } else {"]
    #[doc = r#"         println!("Tock");"#]
    #[doc = r"     }"]
    #[doc = r" }"]
    #[doc = r" ```"]
    macro_rules ! interrupt { ($ NAME : ident , $ path : path , locals : { $ ($ lvar : ident : $ lty : ty = $ lval : expr ;) * }) => { # [allow (non_snake_case)]
mod $ NAME { pub struct Locals { $ (pub $ lvar : $ lty ,) * } } # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; static mut LOCALS : self :: $ NAME :: Locals = self :: $ NAME :: Locals { $ ($ lvar : $ lval ,) * } ; let f : fn (& mut self :: $ NAME :: Locals) = $ path ; f (unsafe { & mut LOCALS }) ; } } ; ($ NAME : ident , $ path : path) => { # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; let f : fn () = $ path ; f () ; } } }
}
pub use self::interrupt::Interrupt;
#[doc = "CTRL"]
pub struct Ctrl {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ctrl {}
impl Ctrl {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ctrl::RegisterBlock = 0xf000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ctrl::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Ctrl {
    type Target = ctrl::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ctrl {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ctrl").finish()
    }
}
#[doc = "CTRL"]
pub mod ctrl {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        reset: Reset,
        scratch: Scratch,
        bus_errors: BusErrors,
    }
    impl RegisterBlock {
        #[doc = "0x00 - "]
        #[inline(always)]
        pub const fn reset(&self) -> &Reset {
            &self.reset
        }
        #[doc = "0x04 - Use this register as a scratch space to verify that software read/write accesses to the Wishbone/CSR bus are working correctly. The initial reset value of 0x1234578 can be used to verify endianness."]
        #[inline(always)]
        pub const fn scratch(&self) -> &Scratch {
            &self.scratch
        }
        #[doc = "0x08 - Total number of Wishbone bus errors (timeouts) since start."]
        #[inline(always)]
        pub const fn bus_errors(&self) -> &BusErrors {
            &self.bus_errors
        }
    }
    #[doc = "RESET (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`reset::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`reset::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reset`]
module"]
    #[doc(alias = "RESET")]
    pub type Reset = crate::Reg<reset::ResetSpec>;
    #[doc = ""]
    pub mod reset {
        #[doc = "Register `RESET` reader"]
        pub type R = crate::R<ResetSpec>;
        #[doc = "Register `RESET` writer"]
        pub type W = crate::W<ResetSpec>;
        #[doc = "Field `soc_rst` reader - Write `1` to this register to reset the full SoC (Pulse Reset)"]
        pub type SocRstR = crate::BitReader;
        #[doc = "Field `soc_rst` writer - Write `1` to this register to reset the full SoC (Pulse Reset)"]
        pub type SocRstW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `cpu_rst` reader - Write `1` to this register to reset the CPU(s) of the SoC (Hold Reset)"]
        pub type CpuRstR = crate::BitReader;
        #[doc = "Field `cpu_rst` writer - Write `1` to this register to reset the CPU(s) of the SoC (Hold Reset)"]
        pub type CpuRstW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Write `1` to this register to reset the full SoC (Pulse Reset)"]
            #[inline(always)]
            pub fn soc_rst(&self) -> SocRstR {
                SocRstR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Write `1` to this register to reset the CPU(s) of the SoC (Hold Reset)"]
            #[inline(always)]
            pub fn cpu_rst(&self) -> CpuRstR {
                CpuRstR::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Write `1` to this register to reset the full SoC (Pulse Reset)"]
            #[inline(always)]
            #[must_use]
            pub fn soc_rst(&mut self) -> SocRstW<ResetSpec> {
                SocRstW::new(self, 0)
            }
            #[doc = "Bit 1 - Write `1` to this register to reset the CPU(s) of the SoC (Hold Reset)"]
            #[inline(always)]
            #[must_use]
            pub fn cpu_rst(&mut self) -> CpuRstW<ResetSpec> {
                CpuRstW::new(self, 1)
            }
        }
        #[doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`reset::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`reset::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ResetSpec;
        impl crate::RegisterSpec for ResetSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`reset::R`](R) reader structure"]
        impl crate::Readable for ResetSpec {}
        #[doc = "`write(|w| ..)` method takes [`reset::W`](W) writer structure"]
        impl crate::Writable for ResetSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets RESET to value 0"]
        impl crate::Resettable for ResetSpec {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "SCRATCH (rw) register accessor: Use this register as a scratch space to verify that software read/write accesses to the Wishbone/CSR bus are working correctly. The initial reset value of 0x1234578 can be used to verify endianness.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`scratch::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`scratch::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@scratch`]
module"]
    #[doc(alias = "SCRATCH")]
    pub type Scratch = crate::Reg<scratch::ScratchSpec>;
    #[doc = "Use this register as a scratch space to verify that software read/write accesses to the Wishbone/CSR bus are working correctly. The initial reset value of 0x1234578 can be used to verify endianness."]
    pub mod scratch {
        #[doc = "Register `SCRATCH` reader"]
        pub type R = crate::R<ScratchSpec>;
        #[doc = "Register `SCRATCH` writer"]
        pub type W = crate::W<ScratchSpec>;
        #[doc = "Field `scratch` reader - "]
        pub type ScratchR = crate::FieldReader<u32>;
        #[doc = "Field `scratch` writer - "]
        pub type ScratchW<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31"]
            #[inline(always)]
            pub fn scratch(&self) -> ScratchR {
                ScratchR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31"]
            #[inline(always)]
            #[must_use]
            pub fn scratch(&mut self) -> ScratchW<ScratchSpec> {
                ScratchW::new(self, 0)
            }
        }
        #[doc = "Use this register as a scratch space to verify that software read/write accesses to the Wishbone/CSR bus are working correctly. The initial reset value of 0x1234578 can be used to verify endianness.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`scratch::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`scratch::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ScratchSpec;
        impl crate::RegisterSpec for ScratchSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`scratch::R`](R) reader structure"]
        impl crate::Readable for ScratchSpec {}
        #[doc = "`write(|w| ..)` method takes [`scratch::W`](W) writer structure"]
        impl crate::Writable for ScratchSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SCRATCH to value 0x1234_5678"]
        impl crate::Resettable for ScratchSpec {
            const RESET_VALUE: u32 = 0x1234_5678;
        }
    }
    #[doc = "BUS_ERRORS (rw) register accessor: Total number of Wishbone bus errors (timeouts) since start.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`bus_errors::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bus_errors::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bus_errors`]
module"]
    #[doc(alias = "BUS_ERRORS")]
    pub type BusErrors = crate::Reg<bus_errors::BusErrorsSpec>;
    #[doc = "Total number of Wishbone bus errors (timeouts) since start."]
    pub mod bus_errors {
        #[doc = "Register `BUS_ERRORS` reader"]
        pub type R = crate::R<BusErrorsSpec>;
        #[doc = "Register `BUS_ERRORS` writer"]
        pub type W = crate::W<BusErrorsSpec>;
        #[doc = "Field `bus_errors` reader - "]
        pub type BusErrorsR = crate::FieldReader<u32>;
        #[doc = "Field `bus_errors` writer - "]
        pub type BusErrorsW<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31"]
            #[inline(always)]
            pub fn bus_errors(&self) -> BusErrorsR {
                BusErrorsR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31"]
            #[inline(always)]
            #[must_use]
            pub fn bus_errors(&mut self) -> BusErrorsW<BusErrorsSpec> {
                BusErrorsW::new(self, 0)
            }
        }
        #[doc = "Total number of Wishbone bus errors (timeouts) since start.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`bus_errors::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bus_errors::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct BusErrorsSpec;
        impl crate::RegisterSpec for BusErrorsSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`bus_errors::R`](R) reader structure"]
        impl crate::Readable for BusErrorsSpec {}
        #[doc = "`write(|w| ..)` method takes [`bus_errors::W`](W) writer structure"]
        impl crate::Writable for BusErrorsSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets BUS_ERRORS to value 0"]
        impl crate::Resettable for BusErrorsSpec {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[doc = "IDENTIFIER_MEM"]
pub struct IdentifierMem {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for IdentifierMem {}
impl IdentifierMem {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const identifier_mem::RegisterBlock = 0xf000_0800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const identifier_mem::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for IdentifierMem {
    type Target = identifier_mem::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for IdentifierMem {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("IdentifierMem").finish()
    }
}
#[doc = "IDENTIFIER_MEM"]
pub mod identifier_mem {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        identifier_mem: IdentifierMem,
    }
    impl RegisterBlock {
        #[doc = "0x00 - 8 x 52-bit memory"]
        #[inline(always)]
        pub const fn identifier_mem(&self) -> &IdentifierMem {
            &self.identifier_mem
        }
    }
    #[doc = "IDENTIFIER_MEM (rw) register accessor: 8 x 52-bit memory\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`identifier_mem::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`identifier_mem::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@identifier_mem`]
module"]
    #[doc(alias = "IDENTIFIER_MEM")]
    pub type IdentifierMem = crate::Reg<identifier_mem::IdentifierMemSpec>;
    #[doc = "8 x 52-bit memory"]
    pub mod identifier_mem {
        #[doc = "Register `IDENTIFIER_MEM` reader"]
        pub type R = crate::R<IdentifierMemSpec>;
        #[doc = "Register `IDENTIFIER_MEM` writer"]
        pub type W = crate::W<IdentifierMemSpec>;
        #[doc = "Field `identifier_mem` reader - "]
        pub type IdentifierMemR = crate::FieldReader;
        #[doc = "Field `identifier_mem` writer - "]
        pub type IdentifierMemW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn identifier_mem(&self) -> IdentifierMemR {
                IdentifierMemR::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            #[must_use]
            pub fn identifier_mem(&mut self) -> IdentifierMemW<IdentifierMemSpec> {
                IdentifierMemW::new(self, 0)
            }
        }
        #[doc = "8 x 52-bit memory\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`identifier_mem::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`identifier_mem::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IdentifierMemSpec;
        impl crate::RegisterSpec for IdentifierMemSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`identifier_mem::R`](R) reader structure"]
        impl crate::Readable for IdentifierMemSpec {}
        #[doc = "`write(|w| ..)` method takes [`identifier_mem::W`](W) writer structure"]
        impl crate::Writable for IdentifierMemSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets IDENTIFIER_MEM to value 0"]
        impl crate::Resettable for IdentifierMemSpec {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[doc = "TIMER0"]
pub struct Timer0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer0 {}
impl Timer0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer0::RegisterBlock = 0xf000_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer0 {
    type Target = timer0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer0").finish()
    }
}
#[doc = "TIMER0"]
pub mod timer0 {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        load: Load,
        reload: Reload,
        en: En,
        update_value: UpdateValue,
        value: Value,
        ev_status: EvStatus,
        ev_pending: EvPending,
        ev_enable: EvEnable,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Load value when Timer is (re-)enabled. In One-Shot mode, the value written to this register specifies the Timer's duration in clock cycles."]
        #[inline(always)]
        pub const fn load(&self) -> &Load {
            &self.load
        }
        #[doc = "0x04 - Reload value when Timer reaches ``0``. In Periodic mode, the value written to this register specify the Timer's period in clock cycles."]
        #[inline(always)]
        pub const fn reload(&self) -> &Reload {
            &self.reload
        }
        #[doc = "0x08 - Enable flag of the Timer. Set this flag to ``1`` to enable/start the Timer. Set to ``0`` to disable the Timer."]
        #[inline(always)]
        pub const fn en(&self) -> &En {
            &self.en
        }
        #[doc = "0x0c - Update trigger for the current countdown value. A write to this register latches the current countdown value to ``value`` register."]
        #[inline(always)]
        pub const fn update_value(&self) -> &UpdateValue {
            &self.update_value
        }
        #[doc = "0x10 - Latched countdown value. This value is updated by writing to ``update_value``."]
        #[inline(always)]
        pub const fn value(&self) -> &Value {
            &self.value
        }
        #[doc = "0x14 - This register contains the current raw level of the zero event trigger. Writes to this register have no effect."]
        #[inline(always)]
        pub const fn ev_status(&self) -> &EvStatus {
            &self.ev_status
        }
        #[doc = "0x18 - When a zero event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register."]
        #[inline(always)]
        pub const fn ev_pending(&self) -> &EvPending {
            &self.ev_pending
        }
        #[doc = "0x1c - This register enables the corresponding zero events. Write a ``0`` to this register to disable individual events."]
        #[inline(always)]
        pub const fn ev_enable(&self) -> &EvEnable {
            &self.ev_enable
        }
    }
    #[doc = "LOAD (rw) register accessor: Load value when Timer is (re-)enabled. In One-Shot mode, the value written to this register specifies the Timer's duration in clock cycles.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`load::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`load::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@load`]
module"]
    #[doc(alias = "LOAD")]
    pub type Load = crate::Reg<load::LoadSpec>;
    #[doc = "Load value when Timer is (re-)enabled. In One-Shot mode, the value written to this register specifies the Timer's duration in clock cycles."]
    pub mod load {
        #[doc = "Register `LOAD` reader"]
        pub type R = crate::R<LoadSpec>;
        #[doc = "Register `LOAD` writer"]
        pub type W = crate::W<LoadSpec>;
        #[doc = "Field `load` reader - "]
        pub type LoadR = crate::FieldReader<u32>;
        #[doc = "Field `load` writer - "]
        pub type LoadW<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31"]
            #[inline(always)]
            pub fn load(&self) -> LoadR {
                LoadR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31"]
            #[inline(always)]
            #[must_use]
            pub fn load(&mut self) -> LoadW<LoadSpec> {
                LoadW::new(self, 0)
            }
        }
        #[doc = "Load value when Timer is (re-)enabled. In One-Shot mode, the value written to this register specifies the Timer's duration in clock cycles.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`load::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`load::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct LoadSpec;
        impl crate::RegisterSpec for LoadSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`load::R`](R) reader structure"]
        impl crate::Readable for LoadSpec {}
        #[doc = "`write(|w| ..)` method takes [`load::W`](W) writer structure"]
        impl crate::Writable for LoadSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets LOAD to value 0"]
        impl crate::Resettable for LoadSpec {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "RELOAD (rw) register accessor: Reload value when Timer reaches ``0``. In Periodic mode, the value written to this register specify the Timer's period in clock cycles.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`reload::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`reload::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reload`]
module"]
    #[doc(alias = "RELOAD")]
    pub type Reload = crate::Reg<reload::ReloadSpec>;
    #[doc = "Reload value when Timer reaches ``0``. In Periodic mode, the value written to this register specify the Timer's period in clock cycles."]
    pub mod reload {
        #[doc = "Register `RELOAD` reader"]
        pub type R = crate::R<ReloadSpec>;
        #[doc = "Register `RELOAD` writer"]
        pub type W = crate::W<ReloadSpec>;
        #[doc = "Field `reload` reader - "]
        pub type ReloadR = crate::FieldReader<u32>;
        #[doc = "Field `reload` writer - "]
        pub type ReloadW<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31"]
            #[inline(always)]
            pub fn reload(&self) -> ReloadR {
                ReloadR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31"]
            #[inline(always)]
            #[must_use]
            pub fn reload(&mut self) -> ReloadW<ReloadSpec> {
                ReloadW::new(self, 0)
            }
        }
        #[doc = "Reload value when Timer reaches ``0``. In Periodic mode, the value written to this register specify the Timer's period in clock cycles.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`reload::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`reload::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ReloadSpec;
        impl crate::RegisterSpec for ReloadSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`reload::R`](R) reader structure"]
        impl crate::Readable for ReloadSpec {}
        #[doc = "`write(|w| ..)` method takes [`reload::W`](W) writer structure"]
        impl crate::Writable for ReloadSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets RELOAD to value 0"]
        impl crate::Resettable for ReloadSpec {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "EN (rw) register accessor: Enable flag of the Timer. Set this flag to ``1`` to enable/start the Timer. Set to ``0`` to disable the Timer.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@en`]
module"]
    #[doc(alias = "EN")]
    pub type En = crate::Reg<en::EnSpec>;
    #[doc = "Enable flag of the Timer. Set this flag to ``1`` to enable/start the Timer. Set to ``0`` to disable the Timer."]
    pub mod en {
        #[doc = "Register `EN` reader"]
        pub type R = crate::R<EnSpec>;
        #[doc = "Register `EN` writer"]
        pub type W = crate::W<EnSpec>;
        #[doc = "Field `en` reader - "]
        pub type EnR = crate::BitReader;
        #[doc = "Field `en` writer - "]
        pub type EnW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn en(&self) -> EnR {
                EnR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            #[must_use]
            pub fn en(&mut self) -> EnW<EnSpec> {
                EnW::new(self, 0)
            }
        }
        #[doc = "Enable flag of the Timer. Set this flag to ``1`` to enable/start the Timer. Set to ``0`` to disable the Timer.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct EnSpec;
        impl crate::RegisterSpec for EnSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`en::R`](R) reader structure"]
        impl crate::Readable for EnSpec {}
        #[doc = "`write(|w| ..)` method takes [`en::W`](W) writer structure"]
        impl crate::Writable for EnSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets EN to value 0"]
        impl crate::Resettable for EnSpec {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "UPDATE_VALUE (rw) register accessor: Update trigger for the current countdown value. A write to this register latches the current countdown value to ``value`` register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`update_value::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`update_value::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@update_value`]
module"]
    #[doc(alias = "UPDATE_VALUE")]
    pub type UpdateValue = crate::Reg<update_value::UpdateValueSpec>;
    #[doc = "Update trigger for the current countdown value. A write to this register latches the current countdown value to ``value`` register."]
    pub mod update_value {
        #[doc = "Register `UPDATE_VALUE` reader"]
        pub type R = crate::R<UpdateValueSpec>;
        #[doc = "Register `UPDATE_VALUE` writer"]
        pub type W = crate::W<UpdateValueSpec>;
        #[doc = "Field `update_value` reader - "]
        pub type UpdateValueR = crate::BitReader;
        #[doc = "Field `update_value` writer - "]
        pub type UpdateValueW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn update_value(&self) -> UpdateValueR {
                UpdateValueR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            #[must_use]
            pub fn update_value(&mut self) -> UpdateValueW<UpdateValueSpec> {
                UpdateValueW::new(self, 0)
            }
        }
        #[doc = "Update trigger for the current countdown value. A write to this register latches the current countdown value to ``value`` register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`update_value::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`update_value::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct UpdateValueSpec;
        impl crate::RegisterSpec for UpdateValueSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`update_value::R`](R) reader structure"]
        impl crate::Readable for UpdateValueSpec {}
        #[doc = "`write(|w| ..)` method takes [`update_value::W`](W) writer structure"]
        impl crate::Writable for UpdateValueSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets UPDATE_VALUE to value 0"]
        impl crate::Resettable for UpdateValueSpec {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "VALUE (rw) register accessor: Latched countdown value. This value is updated by writing to ``update_value``.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`value::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`value::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@value`]
module"]
    #[doc(alias = "VALUE")]
    pub type Value = crate::Reg<value::ValueSpec>;
    #[doc = "Latched countdown value. This value is updated by writing to ``update_value``."]
    pub mod value {
        #[doc = "Register `VALUE` reader"]
        pub type R = crate::R<ValueSpec>;
        #[doc = "Register `VALUE` writer"]
        pub type W = crate::W<ValueSpec>;
        #[doc = "Field `value` reader - "]
        pub type ValueR = crate::FieldReader<u32>;
        #[doc = "Field `value` writer - "]
        pub type ValueW<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31"]
            #[inline(always)]
            pub fn value(&self) -> ValueR {
                ValueR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31"]
            #[inline(always)]
            #[must_use]
            pub fn value(&mut self) -> ValueW<ValueSpec> {
                ValueW::new(self, 0)
            }
        }
        #[doc = "Latched countdown value. This value is updated by writing to ``update_value``.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`value::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`value::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ValueSpec;
        impl crate::RegisterSpec for ValueSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`value::R`](R) reader structure"]
        impl crate::Readable for ValueSpec {}
        #[doc = "`write(|w| ..)` method takes [`value::W`](W) writer structure"]
        impl crate::Writable for ValueSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets VALUE to value 0"]
        impl crate::Resettable for ValueSpec {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "EV_STATUS (rw) register accessor: This register contains the current raw level of the zero event trigger. Writes to this register have no effect.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_status::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_status::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ev_status`]
module"]
    #[doc(alias = "EV_STATUS")]
    pub type EvStatus = crate::Reg<ev_status::EvStatusSpec>;
    #[doc = "This register contains the current raw level of the zero event trigger. Writes to this register have no effect."]
    pub mod ev_status {
        #[doc = "Register `EV_STATUS` reader"]
        pub type R = crate::R<EvStatusSpec>;
        #[doc = "Register `EV_STATUS` writer"]
        pub type W = crate::W<EvStatusSpec>;
        #[doc = "Field `zero` reader - Level of the ``zero`` event"]
        pub type ZeroR = crate::BitReader;
        #[doc = "Field `zero` writer - Level of the ``zero`` event"]
        pub type ZeroW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Level of the ``zero`` event"]
            #[inline(always)]
            pub fn zero(&self) -> ZeroR {
                ZeroR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Level of the ``zero`` event"]
            #[inline(always)]
            #[must_use]
            pub fn zero(&mut self) -> ZeroW<EvStatusSpec> {
                ZeroW::new(self, 0)
            }
        }
        #[doc = "This register contains the current raw level of the zero event trigger. Writes to this register have no effect.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_status::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_status::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct EvStatusSpec;
        impl crate::RegisterSpec for EvStatusSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ev_status::R`](R) reader structure"]
        impl crate::Readable for EvStatusSpec {}
        #[doc = "`write(|w| ..)` method takes [`ev_status::W`](W) writer structure"]
        impl crate::Writable for EvStatusSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets EV_STATUS to value 0"]
        impl crate::Resettable for EvStatusSpec {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "EV_PENDING (rw) register accessor: When a zero event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_pending::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_pending::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ev_pending`]
module"]
    #[doc(alias = "EV_PENDING")]
    pub type EvPending = crate::Reg<ev_pending::EvPendingSpec>;
    #[doc = "When a zero event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register."]
    pub mod ev_pending {
        #[doc = "Register `EV_PENDING` reader"]
        pub type R = crate::R<EvPendingSpec>;
        #[doc = "Register `EV_PENDING` writer"]
        pub type W = crate::W<EvPendingSpec>;
        #[doc = "Field `zero` reader - `1` if a `zero` event occurred. This Event is triggered on a **falling** edge."]
        pub type ZeroR = crate::BitReader;
        #[doc = "Field `zero` writer - `1` if a `zero` event occurred. This Event is triggered on a **falling** edge."]
        pub type ZeroW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - `1` if a `zero` event occurred. This Event is triggered on a **falling** edge."]
            #[inline(always)]
            pub fn zero(&self) -> ZeroR {
                ZeroR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - `1` if a `zero` event occurred. This Event is triggered on a **falling** edge."]
            #[inline(always)]
            #[must_use]
            pub fn zero(&mut self) -> ZeroW<EvPendingSpec> {
                ZeroW::new(self, 0)
            }
        }
        #[doc = "When a zero event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_pending::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_pending::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct EvPendingSpec;
        impl crate::RegisterSpec for EvPendingSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ev_pending::R`](R) reader structure"]
        impl crate::Readable for EvPendingSpec {}
        #[doc = "`write(|w| ..)` method takes [`ev_pending::W`](W) writer structure"]
        impl crate::Writable for EvPendingSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets EV_PENDING to value 0"]
        impl crate::Resettable for EvPendingSpec {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "EV_ENABLE (rw) register accessor: This register enables the corresponding zero events. Write a ``0`` to this register to disable individual events.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_enable::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_enable::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ev_enable`]
module"]
    #[doc(alias = "EV_ENABLE")]
    pub type EvEnable = crate::Reg<ev_enable::EvEnableSpec>;
    #[doc = "This register enables the corresponding zero events. Write a ``0`` to this register to disable individual events."]
    pub mod ev_enable {
        #[doc = "Register `EV_ENABLE` reader"]
        pub type R = crate::R<EvEnableSpec>;
        #[doc = "Register `EV_ENABLE` writer"]
        pub type W = crate::W<EvEnableSpec>;
        #[doc = "Field `zero` reader - Write a ``1`` to enable the ``zero`` Event"]
        pub type ZeroR = crate::BitReader;
        #[doc = "Field `zero` writer - Write a ``1`` to enable the ``zero`` Event"]
        pub type ZeroW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Write a ``1`` to enable the ``zero`` Event"]
            #[inline(always)]
            pub fn zero(&self) -> ZeroR {
                ZeroR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Write a ``1`` to enable the ``zero`` Event"]
            #[inline(always)]
            #[must_use]
            pub fn zero(&mut self) -> ZeroW<EvEnableSpec> {
                ZeroW::new(self, 0)
            }
        }
        #[doc = "This register enables the corresponding zero events. Write a ``0`` to this register to disable individual events.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_enable::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_enable::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct EvEnableSpec;
        impl crate::RegisterSpec for EvEnableSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ev_enable::R`](R) reader structure"]
        impl crate::Readable for EvEnableSpec {}
        #[doc = "`write(|w| ..)` method takes [`ev_enable::W`](W) writer structure"]
        impl crate::Writable for EvEnableSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets EV_ENABLE to value 0"]
        impl crate::Resettable for EvEnableSpec {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[doc = "I2CFIFO"]
pub struct I2cfifo {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2cfifo {}
impl I2cfifo {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2cfifo::RegisterBlock = 0x8100_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2cfifo::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2cfifo {
    type Target = i2cfifo::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2cfifo {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2cfifo").finish()
    }
}
#[doc = "I2CFIFO"]
pub mod i2cfifo {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x20],
        i2cc1: I2cc1,
        _reserved1: [u8; 0xff],
        i2ctxfifo_lsb: I2ctxfifoLsb,
        _reserved2: [u8; 0x0f],
        i2ctxfifo_msb: I2ctxfifoMsb,
        _reserved3: [u8; 0x0f],
        i2crxfifo_lsb: I2crxfifoLsb,
        _reserved4: [u8; 0x0f],
        i2crxfifo_msb: I2crxfifoMsb,
        _reserved5: [u8; 0x2f],
        i2cfifosr_lsb: I2cfifosrLsb,
        _reserved6: [u8; 0x0f],
        i2cfifosr_msb: I2cfifosrMsb,
    }
    impl RegisterBlock {
        #[doc = "0x20 - "]
        #[inline(always)]
        pub const fn i2cc1(&self) -> &I2cc1 {
            &self.i2cc1
        }
        #[doc = "0x120 - "]
        #[inline(always)]
        pub const fn i2ctxfifo_lsb(&self) -> &I2ctxfifoLsb {
            &self.i2ctxfifo_lsb
        }
        #[doc = "0x130 - "]
        #[inline(always)]
        pub const fn i2ctxfifo_msb(&self) -> &I2ctxfifoMsb {
            &self.i2ctxfifo_msb
        }
        #[doc = "0x140 - "]
        #[inline(always)]
        pub const fn i2crxfifo_lsb(&self) -> &I2crxfifoLsb {
            &self.i2crxfifo_lsb
        }
        #[doc = "0x150 - "]
        #[inline(always)]
        pub const fn i2crxfifo_msb(&self) -> &I2crxfifoMsb {
            &self.i2crxfifo_msb
        }
        #[doc = "0x180 - "]
        #[inline(always)]
        pub const fn i2cfifosr_lsb(&self) -> &I2cfifosrLsb {
            &self.i2cfifosr_lsb
        }
        #[doc = "0x190 - "]
        #[inline(always)]
        pub const fn i2cfifosr_msb(&self) -> &I2cfifosrMsb {
            &self.i2cfifosr_msb
        }
    }
    #[doc = "I2CC1 (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2cc1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2cc1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@i2cc1`]
module"]
    #[doc(alias = "I2CC1")]
    pub type I2cc1 = crate::Reg<i2cc1::I2cc1Spec>;
    #[doc = ""]
    pub mod i2cc1 {
        #[doc = "Register `I2CC1` reader"]
        pub type R = crate::R<I2cc1Spec>;
        #[doc = "Register `I2CC1` writer"]
        pub type W = crate::W<I2cc1Spec>;
        #[doc = "Field `i2c_en` reader - "]
        pub type I2cEnR = crate::BitReader;
        #[doc = "Field `i2c_en` writer - "]
        pub type I2cEnW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn i2c_en(&self) -> I2cEnR {
                I2cEnR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 7"]
            #[inline(always)]
            #[must_use]
            pub fn i2c_en(&mut self) -> I2cEnW<I2cc1Spec> {
                I2cEnW::new(self, 7)
            }
        }
        #[doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2cc1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2cc1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct I2cc1Spec;
        impl crate::RegisterSpec for I2cc1Spec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`i2cc1::R`](R) reader structure"]
        impl crate::Readable for I2cc1Spec {}
        #[doc = "`write(|w| ..)` method takes [`i2cc1::W`](W) writer structure"]
        impl crate::Writable for I2cc1Spec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets I2CC1 to value 0x9a"]
        impl crate::Resettable for I2cc1Spec {
            const RESET_VALUE: u8 = 0x9a;
        }
    }
    #[doc = "I2CTXFIFO_LSB (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2ctxfifo_lsb::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2ctxfifo_lsb::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@i2ctxfifo_lsb`]
module"]
    #[doc(alias = "I2CTXFIFO_LSB")]
    pub type I2ctxfifoLsb = crate::Reg<i2ctxfifo_lsb::I2ctxfifoLsbSpec>;
    #[doc = ""]
    pub mod i2ctxfifo_lsb {
        #[doc = "Register `I2CTXFIFO_LSB` reader"]
        pub type R = crate::R<I2ctxfifoLsbSpec>;
        #[doc = "Register `I2CTXFIFO_LSB` writer"]
        pub type W = crate::W<I2ctxfifoLsbSpec>;
        #[doc = "Field `txlsb` reader - "]
        pub type TxlsbR = crate::FieldReader;
        #[doc = "Field `txlsb` writer - "]
        pub type TxlsbW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn txlsb(&self) -> TxlsbR {
                TxlsbR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            #[must_use]
            pub fn txlsb(&mut self) -> TxlsbW<I2ctxfifoLsbSpec> {
                TxlsbW::new(self, 0)
            }
        }
        #[doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2ctxfifo_lsb::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2ctxfifo_lsb::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct I2ctxfifoLsbSpec;
        impl crate::RegisterSpec for I2ctxfifoLsbSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`i2ctxfifo_lsb::R`](R) reader structure"]
        impl crate::Readable for I2ctxfifoLsbSpec {}
        #[doc = "`write(|w| ..)` method takes [`i2ctxfifo_lsb::W`](W) writer structure"]
        impl crate::Writable for I2ctxfifoLsbSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets I2CTXFIFO_LSB to value 0"]
        impl crate::Resettable for I2ctxfifoLsbSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
    #[doc = "I2CTXFIFO_MSB (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2ctxfifo_msb::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2ctxfifo_msb::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@i2ctxfifo_msb`]
module"]
    #[doc(alias = "I2CTXFIFO_MSB")]
    pub type I2ctxfifoMsb = crate::Reg<i2ctxfifo_msb::I2ctxfifoMsbSpec>;
    #[doc = ""]
    pub mod i2ctxfifo_msb {
        #[doc = "Register `I2CTXFIFO_MSB` reader"]
        pub type R = crate::R<I2ctxfifoMsbSpec>;
        #[doc = "Register `I2CTXFIFO_MSB` writer"]
        pub type W = crate::W<I2ctxfifoMsbSpec>;
        #[doc = "Field `cmd` reader - "]
        pub type CmdR = crate::FieldReader;
        #[doc = "Field `cmd` writer - "]
        pub type CmdW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            #[doc = "Bits 0:1"]
            #[inline(always)]
            pub fn cmd(&self) -> CmdR {
                CmdR::new(self.bits & 3)
            }
        }
        impl W {
            #[doc = "Bits 0:1"]
            #[inline(always)]
            #[must_use]
            pub fn cmd(&mut self) -> CmdW<I2ctxfifoMsbSpec> {
                CmdW::new(self, 0)
            }
        }
        #[doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2ctxfifo_msb::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2ctxfifo_msb::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct I2ctxfifoMsbSpec;
        impl crate::RegisterSpec for I2ctxfifoMsbSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`i2ctxfifo_msb::R`](R) reader structure"]
        impl crate::Readable for I2ctxfifoMsbSpec {}
        #[doc = "`write(|w| ..)` method takes [`i2ctxfifo_msb::W`](W) writer structure"]
        impl crate::Writable for I2ctxfifoMsbSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets I2CTXFIFO_MSB to value 0"]
        impl crate::Resettable for I2ctxfifoMsbSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
    #[doc = "I2CRXFIFO_LSB (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2crxfifo_lsb::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2crxfifo_lsb::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@i2crxfifo_lsb`]
module"]
    #[doc(alias = "I2CRXFIFO_LSB")]
    pub type I2crxfifoLsb = crate::Reg<i2crxfifo_lsb::I2crxfifoLsbSpec>;
    #[doc = ""]
    pub mod i2crxfifo_lsb {
        #[doc = "Register `I2CRXFIFO_LSB` reader"]
        pub type R = crate::R<I2crxfifoLsbSpec>;
        #[doc = "Register `I2CRXFIFO_LSB` writer"]
        pub type W = crate::W<I2crxfifoLsbSpec>;
        #[doc = "Field `rx_lsb` reader - "]
        pub type RxLsbR = crate::FieldReader;
        #[doc = "Field `rx_lsb` writer - "]
        pub type RxLsbW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn rx_lsb(&self) -> RxLsbR {
                RxLsbR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            #[must_use]
            pub fn rx_lsb(&mut self) -> RxLsbW<I2crxfifoLsbSpec> {
                RxLsbW::new(self, 0)
            }
        }
        #[doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2crxfifo_lsb::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2crxfifo_lsb::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct I2crxfifoLsbSpec;
        impl crate::RegisterSpec for I2crxfifoLsbSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`i2crxfifo_lsb::R`](R) reader structure"]
        impl crate::Readable for I2crxfifoLsbSpec {}
        #[doc = "`write(|w| ..)` method takes [`i2crxfifo_lsb::W`](W) writer structure"]
        impl crate::Writable for I2crxfifoLsbSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets I2CRXFIFO_LSB to value 0"]
        impl crate::Resettable for I2crxfifoLsbSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
    #[doc = "I2CRXFIFO_MSB (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2crxfifo_msb::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2crxfifo_msb::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@i2crxfifo_msb`]
module"]
    #[doc(alias = "I2CRXFIFO_MSB")]
    pub type I2crxfifoMsb = crate::Reg<i2crxfifo_msb::I2crxfifoMsbSpec>;
    #[doc = ""]
    pub mod i2crxfifo_msb {
        #[doc = "Register `I2CRXFIFO_MSB` reader"]
        pub type R = crate::R<I2crxfifoMsbSpec>;
        #[doc = "Register `I2CRXFIFO_MSB` writer"]
        pub type W = crate::W<I2crxfifoMsbSpec>;
        #[doc = "Field `dfirst` reader - "]
        pub type DfirstR = crate::BitReader;
        #[doc = "Field `dfirst` writer - "]
        pub type DfirstW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn dfirst(&self) -> DfirstR {
                DfirstR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            #[must_use]
            pub fn dfirst(&mut self) -> DfirstW<I2crxfifoMsbSpec> {
                DfirstW::new(self, 0)
            }
        }
        #[doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2crxfifo_msb::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2crxfifo_msb::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct I2crxfifoMsbSpec;
        impl crate::RegisterSpec for I2crxfifoMsbSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`i2crxfifo_msb::R`](R) reader structure"]
        impl crate::Readable for I2crxfifoMsbSpec {}
        #[doc = "`write(|w| ..)` method takes [`i2crxfifo_msb::W`](W) writer structure"]
        impl crate::Writable for I2crxfifoMsbSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets I2CRXFIFO_MSB to value 0"]
        impl crate::Resettable for I2crxfifoMsbSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
    #[doc = "I2CFIFOSR_LSB (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2cfifosr_lsb::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2cfifosr_lsb::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@i2cfifosr_lsb`]
module"]
    #[doc(alias = "I2CFIFOSR_LSB")]
    pub type I2cfifosrLsb = crate::Reg<i2cfifosr_lsb::I2cfifosrLsbSpec>;
    #[doc = ""]
    pub mod i2cfifosr_lsb {
        #[doc = "Register `I2CFIFOSR_LSB` reader"]
        pub type R = crate::R<I2cfifosrLsbSpec>;
        #[doc = "Register `I2CFIFOSR_LSB` writer"]
        pub type W = crate::W<I2cfifosrLsbSpec>;
        #[doc = "Field `arblost` reader - "]
        pub type ArblostR = crate::BitReader;
        #[doc = "Field `arblost` writer - "]
        pub type ArblostW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `busy` reader - "]
        pub type BusyR = crate::BitReader;
        #[doc = "Field `busy` writer - "]
        pub type BusyW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `rnack` reader - "]
        pub type RnackR = crate::BitReader;
        #[doc = "Field `rnack` writer - "]
        pub type RnackW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `rxoverfl` reader - "]
        pub type RxoverflR = crate::BitReader;
        #[doc = "Field `rxoverfl` writer - "]
        pub type RxoverflW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `txoverfl` reader - "]
        pub type TxoverflR = crate::BitReader;
        #[doc = "Field `txoverfl` writer - "]
        pub type TxoverflW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `txserr` reader - "]
        pub type TxserrR = crate::BitReader;
        #[doc = "Field `txserr` writer - "]
        pub type TxserrW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn arblost(&self) -> ArblostR {
                ArblostR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn busy(&self) -> BusyR {
                BusyR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn rnack(&self) -> RnackR {
                RnackR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn rxoverfl(&self) -> RxoverflR {
                RxoverflR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn txoverfl(&self) -> TxoverflR {
                TxoverflR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn txserr(&self) -> TxserrR {
                TxserrR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 1"]
            #[inline(always)]
            #[must_use]
            pub fn arblost(&mut self) -> ArblostW<I2cfifosrLsbSpec> {
                ArblostW::new(self, 1)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            #[must_use]
            pub fn busy(&mut self) -> BusyW<I2cfifosrLsbSpec> {
                BusyW::new(self, 3)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            #[must_use]
            pub fn rnack(&mut self) -> RnackW<I2cfifosrLsbSpec> {
                RnackW::new(self, 4)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            #[must_use]
            pub fn rxoverfl(&mut self) -> RxoverflW<I2cfifosrLsbSpec> {
                RxoverflW::new(self, 5)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            #[must_use]
            pub fn txoverfl(&mut self) -> TxoverflW<I2cfifosrLsbSpec> {
                TxoverflW::new(self, 6)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            #[must_use]
            pub fn txserr(&mut self) -> TxserrW<I2cfifosrLsbSpec> {
                TxserrW::new(self, 7)
            }
        }
        #[doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2cfifosr_lsb::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2cfifosr_lsb::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct I2cfifosrLsbSpec;
        impl crate::RegisterSpec for I2cfifosrLsbSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`i2cfifosr_lsb::R`](R) reader structure"]
        impl crate::Readable for I2cfifosrLsbSpec {}
        #[doc = "`write(|w| ..)` method takes [`i2cfifosr_lsb::W`](W) writer structure"]
        impl crate::Writable for I2cfifosrLsbSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets I2CFIFOSR_LSB to value 0"]
        impl crate::Resettable for I2cfifosrLsbSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
    #[doc = "I2CFIFOSR_MSB (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2cfifosr_msb::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2cfifosr_msb::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@i2cfifosr_msb`]
module"]
    #[doc(alias = "I2CFIFOSR_MSB")]
    pub type I2cfifosrMsb = crate::Reg<i2cfifosr_msb::I2cfifosrMsbSpec>;
    #[doc = ""]
    pub mod i2cfifosr_msb {
        #[doc = "Register `I2CFIFOSR_MSB` reader"]
        pub type R = crate::R<I2cfifosrMsbSpec>;
        #[doc = "Register `I2CFIFOSR_MSB` writer"]
        pub type W = crate::W<I2cfifosrMsbSpec>;
        #[doc = "Field `rdcmpl` reader - "]
        pub type RdcmplR = crate::BitReader;
        #[doc = "Field `rdcmpl` writer - "]
        pub type RdcmplW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `perifrw` reader - "]
        pub type PerifrwR = crate::BitReader;
        #[doc = "Field `perifrw` writer - "]
        pub type PerifrwW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `txoverfl` reader - "]
        pub type TxoverflR = crate::BitReader;
        #[doc = "Field `txoverfl` writer - "]
        pub type TxoverflW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `rxunderfl` reader - "]
        pub type RxunderflR = crate::BitReader;
        #[doc = "Field `rxunderfl` writer - "]
        pub type RxunderflW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `bus_free` reader - "]
        pub type BusFreeR = crate::BitReader;
        #[doc = "Field `bus_free` writer - "]
        pub type BusFreeW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn rdcmpl(&self) -> RdcmplR {
                RdcmplR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn perifrw(&self) -> PerifrwR {
                PerifrwR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn txoverfl(&self) -> TxoverflR {
                TxoverflR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn rxunderfl(&self) -> RxunderflR {
                RxunderflR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn bus_free(&self) -> BusFreeR {
                BusFreeR::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            #[must_use]
            pub fn rdcmpl(&mut self) -> RdcmplW<I2cfifosrMsbSpec> {
                RdcmplW::new(self, 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            #[must_use]
            pub fn perifrw(&mut self) -> PerifrwW<I2cfifosrMsbSpec> {
                PerifrwW::new(self, 1)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            #[must_use]
            pub fn txoverfl(&mut self) -> TxoverflW<I2cfifosrMsbSpec> {
                TxoverflW::new(self, 2)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            #[must_use]
            pub fn rxunderfl(&mut self) -> RxunderflW<I2cfifosrMsbSpec> {
                RxunderflW::new(self, 3)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            #[must_use]
            pub fn bus_free(&mut self) -> BusFreeW<I2cfifosrMsbSpec> {
                BusFreeW::new(self, 4)
            }
        }
        #[doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`i2cfifosr_msb::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`i2cfifosr_msb::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct I2cfifosrMsbSpec;
        impl crate::RegisterSpec for I2cfifosrMsbSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`i2cfifosr_msb::R`](R) reader structure"]
        impl crate::Readable for I2cfifosrMsbSpec {}
        #[doc = "`write(|w| ..)` method takes [`i2cfifosr_msb::W`](W) writer structure"]
        impl crate::Writable for I2cfifosrMsbSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
        }
        #[doc = "`reset()` method sets I2CFIFOSR_MSB to value 0"]
        impl crate::Resettable for I2cfifosrMsbSpec {
            const RESET_VALUE: u8 = 0;
        }
    }
}
#[doc = "UART"]
pub struct Uart {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart {}
impl Uart {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart::RegisterBlock = 0xf000_1800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart {
    type Target = uart::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart").finish()
    }
}
#[doc = "UART"]
pub mod uart {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        rxtx: Rxtx,
        txfull: Txfull,
        rxempty: Rxempty,
        ev_status: EvStatus,
        ev_pending: EvPending,
        ev_enable: EvEnable,
        txempty: Txempty,
        rxfull: Rxfull,
    }
    impl RegisterBlock {
        #[doc = "0x00 - "]
        #[inline(always)]
        pub const fn rxtx(&self) -> &Rxtx {
            &self.rxtx
        }
        #[doc = "0x04 - TX FIFO Full."]
        #[inline(always)]
        pub const fn txfull(&self) -> &Txfull {
            &self.txfull
        }
        #[doc = "0x08 - RX FIFO Empty."]
        #[inline(always)]
        pub const fn rxempty(&self) -> &Rxempty {
            &self.rxempty
        }
        #[doc = "0x0c - This register contains the current raw level of the rx event trigger. Writes to this register have no effect."]
        #[inline(always)]
        pub const fn ev_status(&self) -> &EvStatus {
            &self.ev_status
        }
        #[doc = "0x10 - When a rx event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register."]
        #[inline(always)]
        pub const fn ev_pending(&self) -> &EvPending {
            &self.ev_pending
        }
        #[doc = "0x14 - This register enables the corresponding rx events. Write a ``0`` to this register to disable individual events."]
        #[inline(always)]
        pub const fn ev_enable(&self) -> &EvEnable {
            &self.ev_enable
        }
        #[doc = "0x18 - TX FIFO Empty."]
        #[inline(always)]
        pub const fn txempty(&self) -> &Txempty {
            &self.txempty
        }
        #[doc = "0x1c - RX FIFO Full."]
        #[inline(always)]
        pub const fn rxfull(&self) -> &Rxfull {
            &self.rxfull
        }
    }
    #[doc = "RXTX (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rxtx::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rxtx::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rxtx`]
module"]
    #[doc(alias = "RXTX")]
    pub type Rxtx = crate::Reg<rxtx::RxtxSpec>;
    #[doc = ""]
    pub mod rxtx {
        #[doc = "Register `RXTX` reader"]
        pub type R = crate::R<RxtxSpec>;
        #[doc = "Register `RXTX` writer"]
        pub type W = crate::W<RxtxSpec>;
        #[doc = "Field `rxtx` reader - "]
        pub type RxtxR = crate::FieldReader;
        #[doc = "Field `rxtx` writer - "]
        pub type RxtxW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn rxtx(&self) -> RxtxR {
                RxtxR::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            #[must_use]
            pub fn rxtx(&mut self) -> RxtxW<RxtxSpec> {
                RxtxW::new(self, 0)
            }
        }
        #[doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rxtx::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rxtx::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RxtxSpec;
        impl crate::RegisterSpec for RxtxSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`rxtx::R`](R) reader structure"]
        impl crate::Readable for RxtxSpec {}
        #[doc = "`write(|w| ..)` method takes [`rxtx::W`](W) writer structure"]
        impl crate::Writable for RxtxSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets RXTX to value 0"]
        impl crate::Resettable for RxtxSpec {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "TXFULL (rw) register accessor: TX FIFO Full.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`txfull::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txfull::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@txfull`]
module"]
    #[doc(alias = "TXFULL")]
    pub type Txfull = crate::Reg<txfull::TxfullSpec>;
    #[doc = "TX FIFO Full."]
    pub mod txfull {
        #[doc = "Register `TXFULL` reader"]
        pub type R = crate::R<TxfullSpec>;
        #[doc = "Register `TXFULL` writer"]
        pub type W = crate::W<TxfullSpec>;
        #[doc = "Field `txfull` reader - "]
        pub type TxfullR = crate::BitReader;
        #[doc = "Field `txfull` writer - "]
        pub type TxfullW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn txfull(&self) -> TxfullR {
                TxfullR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            #[must_use]
            pub fn txfull(&mut self) -> TxfullW<TxfullSpec> {
                TxfullW::new(self, 0)
            }
        }
        #[doc = "TX FIFO Full.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`txfull::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txfull::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TxfullSpec;
        impl crate::RegisterSpec for TxfullSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`txfull::R`](R) reader structure"]
        impl crate::Readable for TxfullSpec {}
        #[doc = "`write(|w| ..)` method takes [`txfull::W`](W) writer structure"]
        impl crate::Writable for TxfullSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets TXFULL to value 0"]
        impl crate::Resettable for TxfullSpec {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "RXEMPTY (rw) register accessor: RX FIFO Empty.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rxempty::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rxempty::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rxempty`]
module"]
    #[doc(alias = "RXEMPTY")]
    pub type Rxempty = crate::Reg<rxempty::RxemptySpec>;
    #[doc = "RX FIFO Empty."]
    pub mod rxempty {
        #[doc = "Register `RXEMPTY` reader"]
        pub type R = crate::R<RxemptySpec>;
        #[doc = "Register `RXEMPTY` writer"]
        pub type W = crate::W<RxemptySpec>;
        #[doc = "Field `rxempty` reader - "]
        pub type RxemptyR = crate::BitReader;
        #[doc = "Field `rxempty` writer - "]
        pub type RxemptyW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn rxempty(&self) -> RxemptyR {
                RxemptyR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            #[must_use]
            pub fn rxempty(&mut self) -> RxemptyW<RxemptySpec> {
                RxemptyW::new(self, 0)
            }
        }
        #[doc = "RX FIFO Empty.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rxempty::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rxempty::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RxemptySpec;
        impl crate::RegisterSpec for RxemptySpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`rxempty::R`](R) reader structure"]
        impl crate::Readable for RxemptySpec {}
        #[doc = "`write(|w| ..)` method takes [`rxempty::W`](W) writer structure"]
        impl crate::Writable for RxemptySpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets RXEMPTY to value 0"]
        impl crate::Resettable for RxemptySpec {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "EV_STATUS (rw) register accessor: This register contains the current raw level of the rx event trigger. Writes to this register have no effect.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_status::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_status::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ev_status`]
module"]
    #[doc(alias = "EV_STATUS")]
    pub type EvStatus = crate::Reg<ev_status::EvStatusSpec>;
    #[doc = "This register contains the current raw level of the rx event trigger. Writes to this register have no effect."]
    pub mod ev_status {
        #[doc = "Register `EV_STATUS` reader"]
        pub type R = crate::R<EvStatusSpec>;
        #[doc = "Register `EV_STATUS` writer"]
        pub type W = crate::W<EvStatusSpec>;
        #[doc = "Field `tx` reader - Level of the ``tx`` event"]
        pub type TxR = crate::BitReader;
        #[doc = "Field `tx` writer - Level of the ``tx`` event"]
        pub type TxW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `rx` reader - Level of the ``rx`` event"]
        pub type RxR = crate::BitReader;
        #[doc = "Field `rx` writer - Level of the ``rx`` event"]
        pub type RxW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Level of the ``tx`` event"]
            #[inline(always)]
            pub fn tx(&self) -> TxR {
                TxR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Level of the ``rx`` event"]
            #[inline(always)]
            pub fn rx(&self) -> RxR {
                RxR::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Level of the ``tx`` event"]
            #[inline(always)]
            #[must_use]
            pub fn tx(&mut self) -> TxW<EvStatusSpec> {
                TxW::new(self, 0)
            }
            #[doc = "Bit 1 - Level of the ``rx`` event"]
            #[inline(always)]
            #[must_use]
            pub fn rx(&mut self) -> RxW<EvStatusSpec> {
                RxW::new(self, 1)
            }
        }
        #[doc = "This register contains the current raw level of the rx event trigger. Writes to this register have no effect.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_status::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_status::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct EvStatusSpec;
        impl crate::RegisterSpec for EvStatusSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ev_status::R`](R) reader structure"]
        impl crate::Readable for EvStatusSpec {}
        #[doc = "`write(|w| ..)` method takes [`ev_status::W`](W) writer structure"]
        impl crate::Writable for EvStatusSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets EV_STATUS to value 0"]
        impl crate::Resettable for EvStatusSpec {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "EV_PENDING (rw) register accessor: When a rx event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_pending::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_pending::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ev_pending`]
module"]
    #[doc(alias = "EV_PENDING")]
    pub type EvPending = crate::Reg<ev_pending::EvPendingSpec>;
    #[doc = "When a rx event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register."]
    pub mod ev_pending {
        #[doc = "Register `EV_PENDING` reader"]
        pub type R = crate::R<EvPendingSpec>;
        #[doc = "Register `EV_PENDING` writer"]
        pub type W = crate::W<EvPendingSpec>;
        #[doc = "Field `tx` reader - `1` if a `tx` event occurred. This Event is triggered on a **falling** edge."]
        pub type TxR = crate::BitReader;
        #[doc = "Field `tx` writer - `1` if a `tx` event occurred. This Event is triggered on a **falling** edge."]
        pub type TxW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `rx` reader - `1` if a `rx` event occurred. This Event is triggered on a **falling** edge."]
        pub type RxR = crate::BitReader;
        #[doc = "Field `rx` writer - `1` if a `rx` event occurred. This Event is triggered on a **falling** edge."]
        pub type RxW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - `1` if a `tx` event occurred. This Event is triggered on a **falling** edge."]
            #[inline(always)]
            pub fn tx(&self) -> TxR {
                TxR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - `1` if a `rx` event occurred. This Event is triggered on a **falling** edge."]
            #[inline(always)]
            pub fn rx(&self) -> RxR {
                RxR::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - `1` if a `tx` event occurred. This Event is triggered on a **falling** edge."]
            #[inline(always)]
            #[must_use]
            pub fn tx(&mut self) -> TxW<EvPendingSpec> {
                TxW::new(self, 0)
            }
            #[doc = "Bit 1 - `1` if a `rx` event occurred. This Event is triggered on a **falling** edge."]
            #[inline(always)]
            #[must_use]
            pub fn rx(&mut self) -> RxW<EvPendingSpec> {
                RxW::new(self, 1)
            }
        }
        #[doc = "When a rx event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_pending::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_pending::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct EvPendingSpec;
        impl crate::RegisterSpec for EvPendingSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ev_pending::R`](R) reader structure"]
        impl crate::Readable for EvPendingSpec {}
        #[doc = "`write(|w| ..)` method takes [`ev_pending::W`](W) writer structure"]
        impl crate::Writable for EvPendingSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets EV_PENDING to value 0"]
        impl crate::Resettable for EvPendingSpec {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "EV_ENABLE (rw) register accessor: This register enables the corresponding rx events. Write a ``0`` to this register to disable individual events.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_enable::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_enable::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ev_enable`]
module"]
    #[doc(alias = "EV_ENABLE")]
    pub type EvEnable = crate::Reg<ev_enable::EvEnableSpec>;
    #[doc = "This register enables the corresponding rx events. Write a ``0`` to this register to disable individual events."]
    pub mod ev_enable {
        #[doc = "Register `EV_ENABLE` reader"]
        pub type R = crate::R<EvEnableSpec>;
        #[doc = "Register `EV_ENABLE` writer"]
        pub type W = crate::W<EvEnableSpec>;
        #[doc = "Field `tx` reader - Write a ``1`` to enable the ``tx`` Event"]
        pub type TxR = crate::BitReader;
        #[doc = "Field `tx` writer - Write a ``1`` to enable the ``tx`` Event"]
        pub type TxW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `rx` reader - Write a ``1`` to enable the ``rx`` Event"]
        pub type RxR = crate::BitReader;
        #[doc = "Field `rx` writer - Write a ``1`` to enable the ``rx`` Event"]
        pub type RxW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Write a ``1`` to enable the ``tx`` Event"]
            #[inline(always)]
            pub fn tx(&self) -> TxR {
                TxR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Write a ``1`` to enable the ``rx`` Event"]
            #[inline(always)]
            pub fn rx(&self) -> RxR {
                RxR::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Write a ``1`` to enable the ``tx`` Event"]
            #[inline(always)]
            #[must_use]
            pub fn tx(&mut self) -> TxW<EvEnableSpec> {
                TxW::new(self, 0)
            }
            #[doc = "Bit 1 - Write a ``1`` to enable the ``rx`` Event"]
            #[inline(always)]
            #[must_use]
            pub fn rx(&mut self) -> RxW<EvEnableSpec> {
                RxW::new(self, 1)
            }
        }
        #[doc = "This register enables the corresponding rx events. Write a ``0`` to this register to disable individual events.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_enable::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_enable::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct EvEnableSpec;
        impl crate::RegisterSpec for EvEnableSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ev_enable::R`](R) reader structure"]
        impl crate::Readable for EvEnableSpec {}
        #[doc = "`write(|w| ..)` method takes [`ev_enable::W`](W) writer structure"]
        impl crate::Writable for EvEnableSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets EV_ENABLE to value 0"]
        impl crate::Resettable for EvEnableSpec {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "TXEMPTY (rw) register accessor: TX FIFO Empty.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`txempty::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txempty::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@txempty`]
module"]
    #[doc(alias = "TXEMPTY")]
    pub type Txempty = crate::Reg<txempty::TxemptySpec>;
    #[doc = "TX FIFO Empty."]
    pub mod txempty {
        #[doc = "Register `TXEMPTY` reader"]
        pub type R = crate::R<TxemptySpec>;
        #[doc = "Register `TXEMPTY` writer"]
        pub type W = crate::W<TxemptySpec>;
        #[doc = "Field `txempty` reader - "]
        pub type TxemptyR = crate::BitReader;
        #[doc = "Field `txempty` writer - "]
        pub type TxemptyW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn txempty(&self) -> TxemptyR {
                TxemptyR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            #[must_use]
            pub fn txempty(&mut self) -> TxemptyW<TxemptySpec> {
                TxemptyW::new(self, 0)
            }
        }
        #[doc = "TX FIFO Empty.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`txempty::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txempty::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TxemptySpec;
        impl crate::RegisterSpec for TxemptySpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`txempty::R`](R) reader structure"]
        impl crate::Readable for TxemptySpec {}
        #[doc = "`write(|w| ..)` method takes [`txempty::W`](W) writer structure"]
        impl crate::Writable for TxemptySpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets TXEMPTY to value 0"]
        impl crate::Resettable for TxemptySpec {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "RXFULL (rw) register accessor: RX FIFO Full.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rxfull::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rxfull::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rxfull`]
module"]
    #[doc(alias = "RXFULL")]
    pub type Rxfull = crate::Reg<rxfull::RxfullSpec>;
    #[doc = "RX FIFO Full."]
    pub mod rxfull {
        #[doc = "Register `RXFULL` reader"]
        pub type R = crate::R<RxfullSpec>;
        #[doc = "Register `RXFULL` writer"]
        pub type W = crate::W<RxfullSpec>;
        #[doc = "Field `rxfull` reader - "]
        pub type RxfullR = crate::BitReader;
        #[doc = "Field `rxfull` writer - "]
        pub type RxfullW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn rxfull(&self) -> RxfullR {
                RxfullR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            #[must_use]
            pub fn rxfull(&mut self) -> RxfullW<RxfullSpec> {
                RxfullW::new(self, 0)
            }
        }
        #[doc = "RX FIFO Full.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rxfull::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rxfull::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RxfullSpec;
        impl crate::RegisterSpec for RxfullSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`rxfull::R`](R) reader structure"]
        impl crate::Readable for RxfullSpec {}
        #[doc = "`write(|w| ..)` method takes [`rxfull::W`](W) writer structure"]
        impl crate::Writable for RxfullSpec {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets RXFULL to value 0"]
        impl crate::Resettable for RxfullSpec {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "CTRL"]
    pub ctrl: Ctrl,
    #[doc = "IDENTIFIER_MEM"]
    pub identifier_mem: IdentifierMem,
    #[doc = "TIMER0"]
    pub timer0: Timer0,
    #[doc = "I2CFIFO"]
    pub i2cfifo: I2cfifo,
    #[doc = "UART"]
    pub uart: Uart,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            ctrl: Ctrl {
                _marker: PhantomData,
            },
            identifier_mem: IdentifierMem {
                _marker: PhantomData,
            },
            timer0: Timer0 {
                _marker: PhantomData,
            },
            i2cfifo: I2cfifo {
                _marker: PhantomData,
            },
            uart: Uart {
                _marker: PhantomData,
            },
        }
    }
}
